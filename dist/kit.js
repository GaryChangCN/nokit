// Generated by CoffeeScript 1.8.0
var Promise, colors, fs, kit, kitExtendsFsPromise, which, _,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

colors = require('colors');

_ = require('lodash');

fs = require('nofs');

Promise = fs.Promise;

which = require('./which');


/**
 * All the async functions in `kit` return promise object.
 * Most time I use it to handle files and system staffs.
 * @type {Object}
 */

kit = {};


/**
 * kit extends all the functions of [nofs](https://github.com/ysmood/nofs).
 *
 * [Offline Documentation](?gotoDoc=nofs/readme.md)
 * @example
 * ```coffee
 * kit.readFile('test.txt', 'utf8').then (str) ->
 * 	console.log str
 *
 * kit.outputFile 'a.txt', 'test'
 * .then -> kit.log 'done'
 *
 * kit.writeJSON 'b.json', { a: 10 }
 * .then -> kit.log 'done'
 *
 * kit.mkdirs 'b.json', { a: 10 }
 * .then -> kit.log 'done'
 * ```
 */

kitExtendsFsPromise = 'promise';

_.extend(kit, fs, {

  /**
  	 * The lodash lib.
  	 * @type {Object}
   */
  _: _,
  requireCache: {},

  /**
  	 * An throttled version of `Promise.all`, it runs all the tasks under
  	 * a concurrent limitation.
  	 * To run tasks sequentially, use `kit.compose`.
  	 * @param  {Int} limit The max task to run at a time. It's optional.
  	 * Default is Infinity.
  	 * @param  {Array | Function} list
  	 * If the list is an array, it should be a list of functions or promises,
  	 * and each function will return a promise.
  	 * If the list is a function, it should be a iterator that returns
  	 * a promise, hen it returns `undefined`, the iteration ends.
  	 * @param {Boolean} saveResutls Whether to save each promise's result or
  	 * not. Default is true.
  	 * @param {Function} progress If a task ends, the resolve value will be
  	 * passed to this function.
  	 * @return {Promise}
  	 * @example
  	 * ```coffee
  	 * urls = [
  	 * 	'http://a.com'
  	 * 	'http://b.com'
  	 * 	'http://c.com'
  	 * 	'http://d.com'
  	 * ]
  	 * tasks = [
  	 * 	-> kit.request url[0]
  	 * 	-> kit.request url[1]
  	 * 	-> kit.request url[2]
  	 * 	-> kit.request url[3]
  	 * ]
  	 *
  	 * kit.async(tasks).then ->
  	 * 	kit.log 'all done!'
  	 *
  	 * kit.async(2, tasks).then ->
  	 * 	kit.log 'max concurrent limit is 2'
  	 *
  	 * kit.async 3, ->
  	 * 	url = urls.pop()
  	 * 	if url
  	 * 		kit.request url
  	 * .then ->
  	 * 	kit.log 'all done!'
  	 * ```
   */
  async: function(limit, list, saveResutls, progress) {
    var isIterDone, iter, resutls, running;
    resutls = [];
    running = 0;
    isIterDone = false;
    if (!_.isNumber(limit)) {
      progress = saveResutls;
      saveResutls = list;
      list = limit;
      limit = Infinity;
    }
    if (saveResutls == null) {
      saveResutls = true;
    }
    if (_.isArray(list)) {
      iter = function() {
        var el;
        el = list.pop();
        if (_.isFunction(el)) {
          return el();
        } else {
          return el;
        }
      };
    } else if (_.isFunction(list)) {
      iter = list;
    } else {
      Promise.reject(new Error('unknown list type: ' + typeof list));
    }
    return new Promise(function(resolve, reject) {
      var addTask, allDone, i, _i, _results;
      addTask = function() {
        var p, task;
        task = iter();
        if (isIterDone || task === void 0) {
          isIterDone = true;
          if (running === 0) {
            allDone();
          }
          return false;
        }
        if (_.isFunction(task.then)) {
          p = task;
        } else {
          p = Promise.resolve(task);
        }
        running++;
        p.then(function(ret) {
          running--;
          if (saveResutls) {
            resutls.push(ret);
          }
          if (typeof progress === "function") {
            progress(ret);
          }
          return addTask();
        })["catch"](function(err) {
          running--;
          return reject(err);
        });
        return true;
      };
      allDone = function() {
        if (saveResutls) {
          return resolve(resutls);
        } else {
          return resolve();
        }
      };
      _results = [];
      for (i = _i = 0; 0 <= limit ? _i < limit : _i > limit; i = 0 <= limit ? ++_i : --_i) {
        if (!addTask()) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  },

  /**
  	 * Creates a function that is the composition of the provided functions.
  	 * Besides, it can also accept async function that returns promise.
  	 * It's more powerful than `_.compose`, and it use reverse order for
  	 * passing argument from one function to another.
  	 * See `kit.async`, if you need concurrent support.
  	 * @param  {Function | Array} fns Functions that return
  	 * promise or any value.
  	 * And the array can also contains promises.
  	 * @return {Function} A composed function that will return a promise.
  	 * @example
  	 * ```coffee
  	 * # It helps to decouple sequential pipeline code logic.
  	 *
  	 * createUrl = (name) ->
  	 * 	return "http://test.com/" + name
  	 *
  	 * curl = (url) ->
  	 * 	kit.request(url).then ->
  	 * 		kit.log 'get'
  	 *
  	 * save = (str) ->
  	 * 	kit.outputFile('a.txt', str).then ->
  	 * 		kit.log 'saved'
  	 *
  	 * download = kit.compose createUrl, curl, save
  	 * # same as "download = kit.compose [createUrl, curl, save]"
  	 *
  	 * download 'home'
  	 * ```
   */
  compose: function() {
    var fns;
    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(val) {
      if (_.isArray(fns[0])) {
        fns = fns[0];
      }
      return fns.reduce(function(preFn, fn) {
        if (_.isFunction(fn.then)) {
          return preFn.then(function() {
            return fn;
          });
        } else {
          return preFn.then(fn);
        }
      }, Promise.resolve(val));
    };
  },

  /**
  	 * Daemonize a program. Just a shortcut usage of `kit.spawn`.
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	bin: 'node'
  	 * 	args: ['app.js']
  	 * 	stdout: 'stdout.log' # Can also be a stream
  	 * 	stderr: 'stderr.log' # Can also be a stream
  	 * }
  	 * ```
  	 * @return {Porcess} The daemonized process.
   */
  daemonize: function(opts) {
    var errLog, outLog, p;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      bin: 'node',
      args: ['app.js'],
      stdout: 'stdout.log',
      stderr: 'stderr.log'
    });
    if (_.isString(opts.stdout)) {
      outLog = kit.fs.openSync(opts.stdout, 'a');
    }
    if (_.isString(opts.stderr)) {
      errLog = kit.fs.openSync(opts.stderr, 'a');
    }
    p = kit.spawn(opts.bin, opts.args, {
      detached: true,
      stdio: ['ignore', outLog, errLog]
    }).process;
    p.unref();
    return p;
  },

  /**
  	 * A simple decrypt helper. Cross-version of node.
  	 * @param  {Any} data
  	 * @param  {String | Buffer} password
  	 * @param  {String} algorithm Default is 'aes128'.
  	 * @return {Buffer}
   */
  decrypt: function(data, password, algorithm) {
    var crypto, decipher;
    if (algorithm == null) {
      algorithm = 'aes128';
    }
    crypto = kit.require('crypto');
    decipher = crypto.createDecipher(algorithm, password);
    if (kit.nodeVersion() < 0.10) {
      if (Buffer.isBuffer(data)) {
        data = data.toString('binary');
      }
      return new Buffer(decipher.update(data, 'binary') + decipher.final(), 'binary');
    } else {
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data);
      }
      return Buffer.concat([decipher.update(data), decipher.final()]);
    }
  },

  /**
  	 * A simple encrypt helper. Cross-version of node.
  	 * @param  {Any} data
  	 * @param  {String | Buffer} password
  	 * @param  {String} algorithm Default is 'aes128'.
  	 * @return {Buffer}
   */
  encrypt: function(data, password, algorithm) {
    var cipher, crypto;
    if (algorithm == null) {
      algorithm = 'aes128';
    }
    crypto = kit.require('crypto');
    cipher = crypto.createCipher(algorithm, password);
    if (kit.nodeVersion() < 0.10) {
      if (Buffer.isBuffer(data)) {
        data = data.toString('binary');
      }
      return new Buffer(cipher.update(data, 'binary') + cipher.final(), 'binary');
    } else {
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data);
      }
      return Buffer.concat([cipher.update(data), cipher.final()]);
    }
  },

  /**
  	 * A error log shortcut for `kit.log(msg, 'error', opts)`
  	 * @param  {Any} msg
  	 * @param  {Object} opts
   */
  err: function(msg, opts) {
    if (opts == null) {
      opts = {};
    }
    return kit.log(msg, 'error', opts);
  },

  /**
  	 * A better `child_process.exec`. Supports multi-line shell script.
  	 * For supporting old node version, it will create 3 temp files,
  	 * the temp files will be removed after the execution.
  	 * @param  {String} cmd   Shell commands.
  	 * @param  {String} shell Shell name. Such as `bash`, `zsh`. Optinal.
  	 * @return {Promise} Resolves when the process's stdio is drained.
  	 * The resolve value is like:
  	 * ```coffee
  	 * {
  	 * 	code: 0
  	 * 	signal: null
  	 * 	stdout: 'hello world'
  	 * 	stderr: ''
  	 * }
  	 * ```
  	 * @example
  	 * ```coffee
  	 * kit.exec("""
  	 * 	a='hello world'
  	 *  echo $a
  	 * """).then ({code, stdout}) ->
  	 * 	kit.log code # output => 0
  	 * 	kit.log stdout # output => "hello world"
  	 *
  	 * # Bash doesn't support "**" recusive match pattern.
  	 * kit.exec """
  	 * 	echo **\/*.css
  	 * """, 'zsh'
  	 * ```
   */
  exec: function(cmd, shell) {
    var clean, fileHandlers, os, paths, promise, randName, stderrPath, stdinPath, stdoutPath;
    os = kit.require('os');
    if (shell == null) {
      shell = process.env.SHELL || process.env.ComSpec || process.env.COMSPEC;
    }
    randName = Date.now() + Math.random();
    paths = ['.in', '.out', '.err'].map(function(type) {
      return kit.path.join(os.tmpDir(), 'nobone-' + randName + type);
    });
    stdinPath = paths[0], stdoutPath = paths[1], stderrPath = paths[2];
    fileHandlers = [];
    clean = function() {
      return Promise.all(fileHandlers.map(function(f) {
        return kit.close(f);
      })).then(function() {
        return Promise.all(paths.map(function(p) {
          return kit.remove(p);
        }));
      });
    };
    promise = kit.outputFile(stdinPath, cmd + '\n').then(function() {
      return Promise.all([kit.fs.open(stdinPath, 'r'), kit.fs.open(stdoutPath, 'w'), kit.fs.open(stderrPath, 'w')]);
    }).then(function(stdio) {
      fileHandlers = fileHandlers.concat(stdio);
      return kit.spawn(shell, [], {
        stdio: stdio
      });
    }).then(function(msg) {
      return kit.readFile(stdoutPath, 'utf8').then(function(stdout) {
        return _.extend(msg, {
          stdout: stdout
        });
      });
    })["catch"](function(msg) {
      return kit.readFile(stderrPath, 'utf8').then(function(stderr) {
        _.extend(msg, {
          stderr: stderr
        });
        return Promise.reject(msg);
      });
    });
    promise.then(clean)["catch"](clean);
    return promise;
  },

  /**
  	 * Works much like `gulp.src`, but with Promise instead.
  	 * The flow control and error handling is more pleasant.
  	 * @param  {String} from Glob pattern string.
  	 * @param  {Object} opts It extends the options of `nofs.glob`, but
  	 * with some extra proptereis. Defaults:
  	 * ```coffee
  	 * {
  	 * 	# The base directory of the pattern.
  	 * 	baseDir: String
  	 *
  	 * 	# The encoding of the contents.
  	 * 	# Set null if you want raw buffer.
  	 * 	encoding: 'utf8'
  	 * }
  	 * ```
  	 * @return {Object} The returned flow object has these members:
  	 * ```coffee
  	 * {
  	 * 	pipe: (handler) -> flow
  	 * 	to: (path) -> Promise
  	 * }
  	 * ```
  	 * Each piped handler will recieve a `fileInfo` object:
  	 * ```coffee
  	 * {
  	 * 	# Set the contents and return self.
  	 * 	set: Function
  	 *
  	 * 	# The source path.
  	 * 	path: String
  	 *
  	 * 	# The destination path.
  	 * 	dest: String
  	 *
  	 * 	# The file content.
  	 * 	contents: String | Buffer
  	 *
  	 * 	# All the globbed files.
  	 * 	list: Array
  	 *
  	 * 	# The opts you passed to mapFiles.
  	 * 	opts: Object
  	 * }
  	 * ```
  	 * The handler can have a `onEnd` function, which will be called after the
  	 * whole flow ended. It's optional.
  	 * @example
  	 * ```coffee
  	 * kit.flow 'src/**\/*.js'
  	 * .pipe (fileInfo) ->
  	 * 	fileInfo.set '/* Lisence Info *\/' + fileInfo.contents
  	 * .pipe jslint()
  	 * .pipe minify()
  	 * .to 'build/minified'
  	 * ```
   */
  flow: function(from, opts) {
    var mapper, onEndList, pipeList, reader, set, writer;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      encoding: 'utf8'
    });
    pipeList = [];
    onEndList = [];
    set = function(contents) {
      this.contents = contents;
      return this;
    };
    reader = function(to) {
      return function(fileInfo) {
        return (fileInfo.isDir ? Promise.resolve() : kit.readFile(fileInfo.path, opts.encoding)).then(function(contents) {
          var dest;
          if (opts.baseDir) {
            fileInfo.baseDir = opts.baseDir;
          }
          dest = kit.path.join(to, kit.path.relative(fileInfo.baseDir, fileInfo.path));
          return _.extend(fileInfo, {
            set: set,
            dest: dest,
            opts: opts,
            contents: contents
          });
        });
      };
    };
    writer = function(fileInfo) {
      var contents, dest;
      if (!fileInfo) {
        return;
      }
      dest = fileInfo.dest, contents = fileInfo.contents;
      if ((dest != null) && (contents != null)) {
        return fs.outputFile(dest, contents, fileInfo.opts);
      }
    };
    opts.iter = function(fileInfo, list) {
      list.push(fileInfo);
      return kit.compose(pipeList)(fileInfo);
    };
    return mapper = {
      pipe: function(task) {
        if (_.isFunction(task.onEnd)) {
          onEndList.push(task.onEnd);
        }
        pipeList.push(function(fileInfo) {
          if (fileInfo) {
            return task(fileInfo);
          }
        });
        return mapper;
      },
      to: function(to) {
        pipeList.unshift(reader(to));
        pipeList.push(writer);
        if (onEndList.length > 0) {
          onEndList.push(writer);
        }
        return kit.glob(from, opts).then(function(list) {
          return kit.compose(onEndList)({
            set: set,
            to: to,
            list: list,
            opts: opts
          });
        });
      }
    };
  },

  /**
  	 * Format the parsed comments array to a markdown string.
  	 * @param  {Array}  comments
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	indent: 0
  	 * 	name: ({ name }) ->
  	 * 		name = name.replace 'self.', ''
  	 * 		"- \#\#\#\# #{name}\n\n"
  	 * 	tag: ({ tagName, name, type }) ->
  	 * 		tname = if name then " `#{name}`" else ''
  	 * 		ttype = if type then " { _#{type}_ }" else ''
  	 * 		"- **<u>#{tagName}</u>**:#{tname}#{ttype}"
  	 * }
  	 * ```
  	 * @return {String}
   */
  formatComment: function(comments, opts) {
    var all, cmt, cmtStr, tag, _i, _j, _len, _len1, _ref;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      indent: 0,
      name: function(_arg) {
        var name;
        name = _arg.name;
        name = name.replace('self.', '');
        return "- #### " + name + "\n\n";
      },
      tag: function(_arg) {
        var name, tagName, tname, ttype, type;
        tagName = _arg.tagName, name = _arg.name, type = _arg.type;
        tname = name ? " `" + name + "`" : '';
        ttype = type ? " { _" + type + "_ }" : '';
        return "- **<u>" + tagName + "</u>**:" + tname + ttype;
      }
    });
    all = '';
    for (_i = 0, _len = comments.length; _i < _len; _i++) {
      cmt = comments[_i];
      if (_.any(cmt.tags, {
        tagName: 'private'
      })) {
        continue;
      }
      cmtStr = opts.name(cmt);
      if (cmt.description) {
        cmtStr += kit.indent(cmt.description, 4);
        cmtStr += '\n\n';
      }
      _ref = cmt.tags;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        tag = _ref[_j];
        cmtStr += kit.indent(opts.tag(tag), 4);
        cmtStr += '\n\n';
        if (tag.description) {
          cmtStr += kit.indent(tag.description, 8);
          cmtStr += '\n\n';
        }
      }
      all += cmtStr;
    }
    all = all.replace(/[ \t]+$/mg, '');
    return kit.indent(all, opts.indent);
  },

  /**
  	 * See my project [nofs](https://github.com/ysmood/nofs).
  	 *
  	 * [Offline Documentation](?gotoDoc=nofs/readme.md)
   */
  fs: fs,

  /**
  	 * Generate a list of module paths from a name and a directory.
  	 * @param  {String} moduleName The module name.
  	 * @param  {String} dir        The root path. Default is current working dir.
  	 * @param  {String} modDir     Default is 'node_modules'.
  	 * @return {Array} Paths
   */
  genModulePaths: function(moduleName, dir, modDir) {
    var names, pDir;
    if (dir == null) {
      dir = process.cwd();
    }
    if (modDir == null) {
      modDir = 'node_modules';
    }
    names = [moduleName];
    while (true) {
      names.push(kit.path.join(dir, modDir, moduleName));
      pDir = kit.path.dirname(dir);
      if (dir === pDir) {
        break;
      }
      dir = pDir;
    }
    return names;
  },

  /**
  	 * A fast helper to hash string or binary file.
  	 * See my [jhash](https://github.com/ysmood/jhash) project.
  	 *
  	 * [Offline Documentation](?gotoDoc=jhash/readme.md)
  	 * @example
  	 * ```coffee
  	 * kit.jhash.hash 'test' # output => '349o'
  	 *
  	 * jhash.hash kit.readFileSync('a.jpg')
  	 *
  	 * # Control the hash char set.
  	 * kit.jhash.setSymbols 'abcdef'
  	 * kit.jhash.hash 'test' # output => 'decfddfe'
  	 *
  	 * # Control the max length of the result hash value. Unit is bit.
  	 * jhash.setMaskLen 10
  	 * jhash.hash 'test' # output => 'ede'
  	 * ```
   */
  jhash: require('jhash'),

  /**
  	 * It inserts the fnB in between the fnA and concatenates the result.
  	 * @param  {Any} fnA
  	 * @param  {Any} fnB
  	 * @return {Array}
  	 * @example
  	 * ```coffee
  	 * kit.join([1, 2, 3, 4], 'sep')
  	 * # output => [1, 'sep', 2, 'sep', 3, 'sep', 4]
  	 *
  	 * iter = ->
  	 * 	i = 0
  	 * 	-> i++
  	 * kit.join([1, 2, 3, 4], new iter)
  	 * # output => [1, 'sep', 2, 'sep', 3, 'sep', 4]
  	 * ```
   */
  join: function(fnA, fnB) {
    var arr, iterA, iterB, nextVal, val;
    arr = [];
    iterA = kit.iter(fnA);
    iterB = kit.iter(fnB);
    val = iterA().value;
    while (val !== void 0) {
      arr.push(val);
      nextVal = iterA().value;
      if (nextVal !== void 0) {
        arr.push(iterB().value);
      }
      val = nextVal;
    }
    return arr;
  },

  /**
  	 * Generate a iterator from a value.
  	 * @param  {Any} val
  	 * @return {Function} The every time when the function been
  	 * called, it returns a object looks like:
  	 * ```coffee
  	 * { key: 10, value: 'hello world' }
  	 * ```
  	 * The `key` can be `undefined`, `number` or `string`.
  	 * @example
  	 * ```coffee
  	 * iter = kit.iter [1, 2, 3]
  	 * iter() # output => { key: 0, value: 1 }
  	 *
  	 * iter = kit.iter 'test'
  	 * iter() # output => { key: 0, value: 't' }
  	 *
  	 * iter = kit.iter { a: 1, b: 2, c: 3 }
  	 * iter() # output => { key: 'a', value: 1 }
  	 * ```
   */
  iter: function(val) {
    var i, keys;
    if (_.isArray(val)) {
      i = 0;
      return function() {
        return {
          key: i,
          value: val[i++]
        };
      };
    } else if (_.isFunction(val)) {
      return function() {
        return {
          value: val.apply(void 0, arguments)
        };
      };
    } else if (_.isObject(val)) {
      i = 0;
      keys = _.keys(val);
      return function() {
        var key;
        key = keys[i++];
        return {
          key: key,
          value: val[key]
        };
      };
    } else {
      return function() {
        return {
          value: val
        };
      };
    }
  },

  /**
  	 * Indent a text block.
  	 * @param {String} text
  	 * @param {Int} num
  	 * @param {String} char
  	 * @param {RegExp} reg Default is `/^/mg`.
  	 * @return {String} The indented text block.
  	 * @example
  	 * ```coffee
  	 * # Increase
  	 * kit.indent "one\ntwo", 2
  	 * # => "  one\n  two"
  	 *
  	 * # Decrease
  	 * kit.indent "--one\n--two", 0, '', /^--/mg
  	 * # => "one\ntwo"
  	 * ```
   */
  indent: function(text, num, char, reg) {
    var prefix;
    if (num == null) {
      num = 0;
    }
    if (char == null) {
      char = ' ';
    }
    if (reg == null) {
      reg = /^/mg;
    }
    prefix = _.repeat(char, num);
    return text.replace(reg, prefix);
  },

  /**
  	 * For debugging. Dump a colorful object.
  	 * @param  {Object} obj Your target object.
  	 * @param  {Object} opts Options. Default:
  	 * ```coffee
  	 * { colors: true, depth: 5 }
  	 * ```
  	 * @return {String}
   */
  inspect: function(obj, opts) {
    var str, util;
    util = kit.require('util');
    _.defaults(opts, {
      colors: kit.isDevelopment(),
      depth: 5
    });
    return str = util.inspect(obj, opts);
  },

  /**
  	 * Nobone use it to check the running mode of the app.
  	 * Overwrite it if you want to control the check logic.
  	 * By default it returns the `rocess.env.NODE_ENV == 'development'`.
  	 * @return {Boolean}
   */
  isDevelopment: function() {
    return process.env.NODE_ENV === 'development';
  },

  /**
  	 * Nobone use it to check the running mode of the app.
  	 * Overwrite it if you want to control the check logic.
  	 * By default it returns the `rocess.env.NODE_ENV == 'production'`.
  	 * @return {Boolean}
   */
  isProduction: function() {
    return process.env.NODE_ENV === 'production';
  },

  /**
  	 * A better log for debugging, it uses the `kit.inspect` to log.
  	 *
  	 * Use terminal command like `logReg='pattern' node app.js` to
  	 * filter the log info.
  	 *
  	 * Use `logTrace='on' node app.js` to force each log end with a
  	 * stack trace.
  	 * @param  {Any} msg Your log message.
  	 * @param  {String} action 'log', 'error', 'warn'.
  	 * @param  {Object} opts Default is same with `kit.inspect`,
  	 * but with some extra options:
  	 * ```coffee
  	 * {
  	 * 	isShowTime: true
  	 * }
  	 * ```
   */
  log: function(msg, action, opts) {
    var log, time, timeDelta;
    if (action == null) {
      action = 'log';
    }
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      isShowTime: true
    });
    if (!kit.lastLogTime) {
      kit.lastLogTime = new Date;
      if (process.env.logReg) {
        kit.logReg = new RegExp(process.env.logReg);
      }
    }
    if (opts.isShowTime) {
      time = new Date();
      timeDelta = (+time - +kit.lastLogTime).toString().magenta + 'ms';
      kit.lastLogTime = time;
      time = [[_.padLeft(time.getFullYear(), 4, '0'), _.padLeft(time.getMonth() + 1, 2, '0'), _.padLeft(time.getDate(), 2, '0')].join('-'), [_.padLeft(time.getHours(), 2, '0'), _.padLeft(time.getMinutes(), 2, '0'), _.padLeft(time.getSeconds(), 2, '0')].join(':')].join(' ').grey;
    }
    log = function() {
      var err, str;
      str = _.toArray(arguments).join(' ');
      if (kit.logReg && !kit.logReg.test(str)) {
        return;
      }
      console[action](str);
      if (process.env.logTrace === 'on') {
        err = (new Error).stack.replace(/.+\n.+\n.+/, '\nStack trace:').grey;
        return console.log(err);
      }
    };
    if (_.isObject(msg)) {
      if (opts.isShowTime) {
        log(("[" + time + "] ->\n") + kit.inspect(msg, opts), timeDelta);
      } else {
        log(kit.inspect(msg, opts), timeDelta);
      }
    } else {
      if (opts.isShowTime) {
        log(("[" + time + "] ") + msg, timeDelta);
      } else {
        log(msg, timeDelta);
      }
    }
    if (action === 'error') {
      process.stdout.write("\u0007");
    }
  },

  /**
  	 * Monitor an application and automatically restart it when file changed.
  	 * Even when the monitored app exit with error, the monitor will still wait
  	 * for your file change to restart the application. Not only nodejs, but also
  	 * other programs like ruby or python.
  	 * It will print useful infomation when it application unexceptedly.
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	bin: 'node'
  	 * 	args: ['index.js']
  	 * 	watchList: [] # By default, the same with the "args".
  	 * 	isNodeDeps: true
  	 * 	opts: {} # Same as the opts of 'kit.spawn'.
  	 *
  	 * 	# The option of `kit.parseDependency`
  	 * 	parseDependency: {}
  	 *
  	 * 	onStart: ->
  	 * 		kit.log "Monitor: ".yellow + opts.watchList
  	 * 	onRestart: (path) ->
  	 * 		kit.log "Reload app, modified: ".yellow + path
  	 * 	onWatchFiles: (paths) ->
  	 * 		kit.log 'Watching:'.yellow + paths.join(', ')
  	 * 	onNormalExit: ({ code, signal }) ->
  	 * 		kit.log 'EXIT'.yellow +
  	 * 			" code: #{(code + '').cyan} signal: #{(signal + '').cyan}"
  	 * 	onErrorExit: ({ code, signal }) ->
  	 * 		kit.err 'EXIT'.yellow +
  	 * 		" code: #{(code + '').cyan} signal: #{(signal + '').cyan}\n" +
  	 * 		'Process closed. Edit and save
  	 * 			the watched file to restart.'.red
  	 * 	sepLine: ->
  	 * 		process.stdout.write _.repeat('*', process.stdout.columns).yellow
  	 * }
  	 * ```
  	 * @return {Promise} It has a property `process`, which is the monitored
  	 * child process.
  	 * @example
  	 * ```coffee
  	 * kit.monitorApp {
  	 * 	bin: 'coffee'
  	 * 	args: ['main.coffee']
  	 * }
  	 *
  	 * kit.monitorApp {
  	 * 	bin: 'ruby'
  	 * 	args: ['app.rb', 'lib\/**\/*.rb']
  	 * 	isNodeDeps: false
  	 * }
  	 * ```
   */
  monitorApp: function(opts) {
    var childPromise, start, watcher;
    _.defaults(opts, {
      bin: 'node',
      args: ['index.js'],
      watchList: null,
      isNodeDeps: true,
      parseDependency: {},
      opts: {},
      onStart: function() {
        return kit.log("Monitor: ".yellow + opts.watchList);
      },
      onRestart: function(path) {
        return kit.log("Reload app, modified: ".yellow + path);
      },
      onWatchFiles: function(paths) {
        return kit.log('Watching: '.yellow + paths.join(', '));
      },
      onNormalExit: function(_arg) {
        var code, signal;
        code = _arg.code, signal = _arg.signal;
        return kit.log('EXIT'.yellow + (" code: " + (code + '').cyan + " signal: " + (signal + '').cyan));
      },
      onErrorExit: function(_arg) {
        var code, signal;
        code = _arg.code, signal = _arg.signal;
        return kit.err('EXIT'.yellow + (" code: " + (code + '').cyan + " signal: " + (signal + '').cyan + "\n") + 'Process closed. Edit and save the watched file to restart.'.red);
      },
      sepLine: function() {
        return process.stdout.write(_.repeat('*', process.stdout.columns).yellow);
      }
    });
    if (opts.watchList == null) {
      opts.watchList = opts.args;
    }
    childPromise = null;
    start = function() {
      opts.sepLine();
      childPromise = kit.spawn(opts.bin, opts.args, opts.opts);
      return childPromise.then(function(msg) {
        return opts.onNormalExit(msg);
      })["catch"](function(err) {
        if (err.stack) {
          return Promise.reject(err.stack);
        }
        return opts.onErrorExit(err);
      });
    };
    watcher = function(path, curr, prev) {
      if (curr.mtime !== prev.mtime) {
        opts.onRestart(path);
        childPromise["catch"](function() {}).then(start);
        return childPromise.process.kill('SIGINT');
      }
    };
    process.on('SIGINT', function() {
      childPromise.process.kill('SIGINT');
      return process.exit();
    });
    if (opts.isNodeDeps) {
      kit.parseDependency(opts.watchList, opts.parseDependency).then(function(paths) {
        opts.onWatchFiles(paths);
        return kit.watchFiles(paths, {
          handler: watcher
        });
      });
    } else {
      kit.watchFiles(opts.watchList, {
        handler: watcher
      });
    }
    opts.onStart();
    start();
    return childPromise;
  },

  /**
  	 * Node version. Such as `v0.10.23` is `0.1023`, `v0.10.1` is `0.1001`.
  	 * @type {Float}
   */
  nodeVersion: function() {
    var ms, str;
    ms = process.versions.node.match(/(\d+)\.(\d+)\.(\d+)/);
    str = ms[1] + '.' + _.padLeft(ms[2], 2, '0') + _.padLeft(ms[3], 2, '0');
    return +str;
  },

  /**
  	 * Open a thing that your system can recognize.
  	 * Now only support Windows, OSX or system that installed 'xdg-open'.
  	 * @param  {String | Array} cmds  The thing you want to open.
  	 * @param  {Object} opts The options of the node native
  	 * `child_process.exec`.
  	 * @return {Promise} When the child process exists.
  	 * @example
  	 * ```coffee
  	 * # Open a webpage with the default browser.
  	 * kit.open 'http://ysmood.org'
  	 * ```
   */
  xopen: function(cmds, opts) {
    if (opts == null) {
      opts = {};
    }
    return (Promise.resolve((function() {
      switch (process.platform) {
        case 'darwin':
          return 'open';
        case 'win32':
          return 'start';
        default:
          try {
            return kit.which('xdg-open');
          } catch (_error) {
            return null;
          }
      }
    })())).then(function(starter) {
      if (!starter) {
        return;
      }
      if (_.isString(cmds)) {
        cmds = [cmds];
      }
      return kit.spawn(starter, cmds);
    });
  },

  /**
  	 * A comments parser for javascript and coffee-script.
  	 * Used to generate documentation from source code automatically.
  	 * It will traverse through all the comments of a coffee file.
  	 * @param  {String} code Coffee source code.
  	 * @param  {Object} opts Parser options:
  	 * ```coffee
  	 * {
  	 * 	commentReg: RegExp
  	 * 	splitReg: RegExp
  	 * 	tagNameReg: RegExp
  	 * 	typeReg: RegExp
  	 * 	nameReg: RegExp
  	 * 	nameTags: ['param', 'property']
  	 * 	descriptionReg: RegExp
  	 * }
  	 * ```
  	 * @return {Array} The parsed comments. Each item is something like:
  	 * ```coffee
  	 * {
  	 * 	name: 'parseComment'
  	 * 	description: 'A comments parser for coffee-script.'
  	 * 	tags: [
  	 * 		{
  	 * 			tagName: 'param'
  	 * 			type: 'string'
  	 * 			name: 'code'
  	 * 			description: 'The name of the module it belongs to.'
  	 * 			index: 256 # The target char index in the file.
  	 * 			line: 32 # The line number of the target in the file.
  	 * 		}
  	 * 	]
  	 * }
  	 * ```
   */
  parseComment: function(code, opts) {
    var comments, info, m, parseInfo;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      commentReg: /(?:\#\#\#|\/\*)\*([\s\S]+?)(?:\#\#\#|\*\/)\s+(?:var\s+)?([\w\.-]+)/g,
      splitReg: /^\s+\* @/m,
      tagNameReg: /^([\w\.]+)\s*/,
      typeReg: /^\{(.+?)\}\s*/,
      nameReg: /^(\w+)\s*/,
      nameTags: ['param', 'property'],
      descriptionReg: /^([\s\S]*)/
    });
    parseInfo = function(block) {
      var arr;
      block = block.replace(/\\\//g, '/');
      arr = block.split(opts.splitReg).map(function(el) {
        return el.replace(/^[ \t]+\*[ \t]?/mg, '').trim();
      });
      return {
        description: arr[0] || '',
        tags: arr.slice(1).map(function(el) {
          var parseTag, tag, type, _ref;
          parseTag = function(reg) {
            var m;
            m = el.match(reg);
            if (m && m[1]) {
              el = el.slice(m[0].length);
              return m[1];
            } else {
              return null;
            }
          };
          tag = {};
          tag.tagName = parseTag(opts.tagNameReg);
          type = parseTag(opts.typeReg);
          if (type) {
            tag.type = type;
            if (_ref = tag.tagName, __indexOf.call(opts.nameTags, _ref) >= 0) {
              tag.name = parseTag(opts.nameReg);
            }
            tag.description = parseTag(opts.descriptionReg) || '';
          } else {
            tag.description = parseTag(opts.descriptionReg) || '';
          }
          return tag;
        })
      };
    };
    comments = [];
    m = null;
    while ((m = opts.commentReg.exec(code)) !== null) {
      info = parseInfo(m[1]);
      comments.push({
        name: m[2],
        description: info.description,
        tags: info.tags,
        index: opts.commentReg.lastIndex,
        line: _.reduce(code.slice(0, opts.commentReg.lastIndex), function(count, char) {
          if (char === '\n') {
            count++;
          }
          return count;
        }, 1)
      });
    }
    return comments;
  },

  /**
  	 * Parse commment from a js or coffee file, and output a markdown string.
  	 * @param  {String} path
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 		name: ''
  	 * 		parseComment: {}
  	 * 		formatComment: {
  	 * 			name: ({ name, line }) ->
  	 * 				name = name.replace 'self.', ''
  	 * 				link = "#{path}?source#L#{line}"
  	 * 				"- \#\#\# **[#{name}](#{link})**\n\n"
  	 * 		}
  	 * }
  	 * ```
  	 * @return {String}
   */
  parseFileComment: function(path, opts) {
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      name: '',
      parseComment: {},
      formatComment: {
        name: function(_arg) {
          var line, link, name;
          name = _arg.name, line = _arg.line;
          name = name.replace('self.', '');
          link = "" + path + "?source#L" + line;
          return "- ### **[" + name + "](" + link + ")**\n\n";
        }
      }
    });
    return kit.readFile(path, 'utf8').then(function(str) {
      return kit.parseComment(str, opts.parseComment);
    }).then(function(comments) {
      var ret;
      ret = kit.formatComment(comments, opts.formatComment);
      return ret;
    });
  },

  /**
  	 * Parse dependency tree by regex. The dependency relationships
  	 * is not a tree, but a graph. To avoid dependency cycle, this
  	 * function only return an linear array of the dependencies,
  	 * from which you won't get the detail relationshops between files.
  	 * @param  {String | Array} entryPaths The file to begin with.
  	 * @param  {Object} opts Defaults:
  	 * ```coffee
  	 * {
  	 * 	depReg: /require\s*\(?['"](.+)['"]\)?/gm
  	 * 	depRoots: ['']
  	 * 	extensions: ['.js', '.coffee', 'index.js', 'index.coffee']
  	 *
  	 * 	# It will handle all the matched paths.
  	 * 	# Return false value if you don't want this match.
  	 * 	handle: (path) ->
  	 * 		path.replace(/^[\s'"]+/, '').replace(/[\s'";]+$/, '')
  	 * }
  	 * ```
  	 * @return {Promise} It resolves the dependency path array.
  	 * @example
  	 * ```coffee
  	 * kit.parseDependency 'main.', {
  	 * 	depReg: /require\s*\(?['"](.+)['"]\)?/gm
  	 *  handle: (path) ->
  	 * 		return path if path.match /^(?:\.|\/|[a-z]:)/i
  	 * }
  	 * ```
   */
  parseDependency: function(entryPaths, opts, depPaths) {
    var winSep;
    if (opts == null) {
      opts = {};
    }
    if (depPaths == null) {
      depPaths = {};
    }
    _.defaults(opts, {
      depReg: /require\s*\(?['"](.+)['"]\)?/g,
      depRoots: [''],
      extensions: ['.js', '.coffee', '/index.js', '/index.coffee'],
      handle: function(path) {
        if (path.match(/^(?:\.|\/|[a-z]:)/i)) {
          return path;
        }
      }
    });
    winSep = /\\/g;
    if (_.isString(entryPaths)) {
      entryPaths = [entryPaths];
    }
    entryPaths = entryPaths.reduce(function(s, p) {
      if (kit.path.extname(p)) {
        return s.concat([p]);
      } else {
        return s.concat(opts.extensions.map(function(ext) {
          return p + ext;
        }));
      }
    }, []);
    if (opts.depRoots.indexOf('') === -1) {
      opts.depRoots.push('');
    }
    entryPaths = entryPaths.reduce(function(s, p) {
      return s.concat(opts.depRoots.map(function(root) {
        return kit.path.join(root, p);
      }));
    }, []);
    return Promise.all(entryPaths.map(function(entryPath) {
      return (entryPath.indexOf('*') > -1 ? kit.glob(entryPaths) : kit.fileExists(entryPath).then(function(exists) {
        if (exists) {
          return [entryPath];
        } else {
          return [];
        }
      })).then(function(paths) {
        return Promise.all(paths.map(function(path) {
          if (depPaths[path]) {
            return;
          }
          return kit.readFile(path, 'utf8').then(function(str) {
            var dir;
            depPaths[path.replace(winSep, '/')] = true;
            dir = kit.path.dirname(path);
            entryPaths = [];
            str.replace(opts.depReg, function(m, p) {
              p = opts.handle(p);
              if (!p) {
                return;
              }
              entryPaths.push(p);
              return entryPaths.push(kit.path.join(dir, p));
            });
            return kit.parseDependency(entryPaths, opts, depPaths);
          });
        }));
      });
    })).then(function() {
      return _.keys(depPaths);
    });
  },

  /**
  	 * io.js native module `path`. See `nofs` for more information.
   */
  path: fs.path,

  /**
  	 * The promise lib. Now, it uses Bluebird as ES5 polyfill.
  	 * In the future, the Bluebird will be replaced with native
  	 * ES6 Promise. Please don't use any API other than the ES6 spec.
  	 * @type {Object}
   */
  Promise: Promise,

  /**
  	 * Convert a callback style function to a promise function.
  	 * @param  {Function} fn
  	 * @param  {Any}      this `this` object of the function.
  	 * @return {Function} The function will return a promise object.
  	 * @example
  	 * ```coffee
  	 * readFile = kit.promisify fs.readFile, fs
  	 * readFile('a.txt').then kit.log
  	 * ```
   */
  promisify: fs.promisify,

  /**
  	 * Much faster than the native require of node, but you should
  	 * follow some rules to use it safely.
  	 * @param  {String}   moduleName Relative moudle path is not allowed!
  	 * Only allow absolute path or module name.
  	 * @param  {Function} done Run only the first time after the module loaded.
  	 * @return {Module} The module that you require.
   */
  require: function(moduleName, done) {
    var name, names, p, _i, _j, _len, _len1, _ref;
    if (!kit.requireCache[moduleName]) {
      if (moduleName[0] === '.') {
        throw new Error('Relative path is not allowed: ' + moduleName);
      }
      names = kit.genModulePaths(moduleName, process.cwd());
      if (process.env.NODE_PATH) {
        _ref = process.env.NODE_PATH.split(kit.path.delimiter);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          names.push(kit.path.join(p, moduleName));
        }
      }
      for (_j = 0, _len1 = names.length; _j < _len1; _j++) {
        name = names[_j];
        try {
          kit.requireCache[moduleName] = require(name);
          if (typeof done === "function") {
            done(kit.requireCache[moduleName]);
          }
          break;
        } catch (_error) {}
      }
    }
    if (!kit.requireCache[moduleName]) {
      throw new Error('Module not found: ' + moduleName);
    }
    return kit.requireCache[moduleName];
  },

  /**
  	 * Require an optional package. If not found, it will
  	 * warn user to npm install it, and exit the process.
  	 * @param  {String} name Package name
  	 * @return {Any} The required package.
   */
  requireOptional: function(name) {
    var err;
    try {
      return kit.require(name);
    } catch (_error) {
      err = _error;
      console.error(err.stack + "\nError: Please ".red + ("'npm install " + name + "'").green + " first. If it is a global lib, ".red + ("'npm install -g " + name + "'").green + " first.".red);
      return process.exit();
    }
  },

  /**
  	 * A handy extended combination of `http.request` and `https.request`.
  	 * @param  {Object} opts The same as the [http.request](http://nodejs.org/api/http.html#httpHttpRequestOptionsCallback),
  	 * but with some extra options:
  	 * ```coffee
  	 * {
  	 * 	url: 'It is not optional, String or Url Object.'
  	 *
  	 * 	# Other than return `res` with `res.body`,return `body` directly.
  	 * 	body: true
  	 *
  	 * 	# Max times of auto redirect. If 0, no auto redirect.
  	 * 	redirect: 0
  	 *
  	 * 	# Timeout of the socket of the http connection.
  	 * 	# If timeout happens, the promise will reject.
  	 * 	# Zero means no timeout.
  	 * 	timeout: 0
  	 *
  	 * 	# The key of headers should be lowercased.
  	 * 	headers: {}
  	 *
  	 * 	host: 'localhost'
  	 * 	hostname: 'localhost'
  	 * 	port: 80
  	 * 	method: 'GET'
  	 * 	path: '/'
  	 * 	auth: ''
  	 * 	agent: null
  	 *
  	 * 	# Set "transfer-encoding" header to 'chunked'.
  	 * 	setTE: false
  	 *
  	 * 	# Set null to use buffer, optional.
  	 * 	# It supports GBK, ShiftJIS etc.
  	 * 	# For more info, see https://github.com/ashtuchkin/iconv-lite
  	 * 	resEncoding: 'auto'
  	 *
  	 * 	# It's string, object or buffer, optional. When it's an object,
  	 * 	# The request will be 'application/x-www-form-urlencoded'.
  	 * 	reqData: null
  	 *
  	 * 	# auto end the request.
  	 * 	autoEndReq: true
  	 *
  	 * 	# Readable stream.
  	 * 	reqPipe: null
  	 *
  	 * 	# Writable stream.
  	 * 	resPipe: null
  	 *
  	 * 	# The progress of the request.
  	 * 	reqProgress: (complete, total) ->
  	 *
  	 * 	# The progress of the response.
  	 * 	resProgress: (complete, total) ->
  	 * }
  	 * ```
  	 * And if set opts as string, it will be treated as the url.
  	 * @return {Promise} Contains the http response object,
  	 * it has an extra `body` property.
  	 * You can also get the request object by using `Promise.req`.
  	 * @example
  	 * ```coffee
  	 * p = kit.request 'http://test.com'
  	 * p.req.on 'response', (res) ->
  	 * 	kit.log res.headers['content-length']
  	 * p.then (body) ->
  	 * 	kit.log body # html or buffer
  	 *
  	 * kit.request {
  	 * 	url: 'https://test.com/a.mp3'
  	 * 	body: false
  	 * 	resProgress: (complete, total) ->
  	 * 		kit.log "Progress: #{complete} / #{total}"
  	 * }
  	 * .then (res) ->
  	 * 	kit.log res.body.length
  	 * 	kit.log res.headers
  	 *
  	 * # Send form-data.
  	 * form = new (require 'form-data')
  	 * form.append 'a.jpg', new Buffer(0)
  	 * form.append 'b.txt', 'hello world!'
  	 * kit.request {
  	 * 	url: 'a.com'
  	 * 	headers: form.getHeaders()
  	 * 	setTE: true
  	 * 	reqPipe: form
  	 * }
  	 * .then (body) ->
  	 * 	kit.log body
  	 * ```
   */
  request: function(opts) {
    var promise, req, reqBuf, request, url, _base, _base1, _base2;
    if (_.isString(opts)) {
      opts = {
        url: opts
      };
    }
    if (_.isObject(opts.url)) {
      if ((_base = opts.url).protocol == null) {
        _base.protocol = 'http:';
      }
      opts.url = kit.url.format(opts.url);
    } else {
      if (opts.url.indexOf('http') !== 0) {
        opts.url = 'http://' + opts.url;
      }
    }
    url = kit.url.parse(opts.url);
    delete url.host;
    if (url.protocol == null) {
      url.protocol = 'http:';
    }
    request = null;
    switch (url.protocol) {
      case 'http:':
        request = kit.require('http').request;
        break;
      case 'https:':
        request = kit.require('https').request;
        break;
      default:
        Promise.reject(new Error('Protocol not supported: ' + url.protocol));
    }
    _.defaults(opts, url);
    _.defaults(opts, {
      body: true,
      resEncoding: 'auto',
      reqData: null,
      autoEndReq: true,
      autoUnzip: true,
      reqProgress: null,
      resProgress: null
    });
    if (opts.headers == null) {
      opts.headers = {};
    }
    if (Buffer.isBuffer(opts.reqData)) {
      reqBuf = opts.reqData;
    } else if (_.isString(opts.reqData)) {
      reqBuf = new Buffer(opts.reqData);
    } else if (_.isObject(opts.reqData)) {
      if ((_base1 = opts.headers)['content-type'] == null) {
        _base1['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8';
      }
      reqBuf = new Buffer(_.map(opts.reqData, function(v, k) {
        return [encodeURIComponent(k), encodeURIComponent(v)].join('=');
      }).join('&'));
    } else {
      reqBuf = void 0;
    }
    if (reqBuf !== void 0) {
      if ((_base2 = opts.headers)['content-length'] == null) {
        _base2['content-length'] = reqBuf.length;
      }
    }
    if (opts.setTE) {
      opts.headers['transfer-encoding'] = 'chunked';
    }
    req = null;
    promise = new Promise(function(resolve, reject) {
      req = request(opts, function(res) {
        var buf, resPipeError, unzip;
        if (opts.redirect > 0 && res.headers.location) {
          opts.redirect--;
          url = kit.url.resolve(kit.url.format(opts), res.headers.location);
          kit.request(_.extend(opts, kit.url.parse(url))).then(resolve)["catch"](reject);
          return;
        }
        if (opts.resProgress) {
          (function() {
            var complete, total;
            total = +res.headers['content-length'];
            complete = 0;
            return res.on('data', function(chunk) {
              complete += chunk.length;
              return opts.resProgress(complete, total);
            });
          })();
        }
        if (opts.resPipe) {
          resPipeError = function(err) {
            opts.resPipe.end();
            return reject(err);
          };
          if (opts.autoUnzip) {
            switch (res.headers['content-encoding']) {
              case 'gzip':
                unzip = kit.require('zlib').createGunzip();
                break;
              case 'deflate':
                unzip = kit.require('zlib').createInflat();
                break;
              default:
                unzip = null;
            }
            if (unzip) {
              unzip.on('error', resPipeError);
              res.pipe(unzip).pipe(opts.resPipe);
            } else {
              res.pipe(opts.resPipe);
            }
          } else {
            res.pipe(opts.resPipe);
          }
          opts.resPipe.on('error', resPipeError);
          res.on('error', resPipeError);
          return res.on('end', function() {
            return resolve(res);
          });
        } else {
          buf = new Buffer(0);
          res.on('data', function(chunk) {
            return buf = Buffer.concat([buf, chunk]);
          });
          return res.on('end', function() {
            var cType, decode, encoding, m, resolver;
            resolver = function(body) {
              if (opts.body) {
                return resolve(body);
              } else {
                res.body = body;
                return resolve(res);
              }
            };
            if (opts.resEncoding) {
              if (opts.resEncoding === 'auto') {
                encoding = 'utf8';
                cType = res.headers['content-type'];
                if (_.isString(cType)) {
                  m = cType.match(/charset=(.+);?/i);
                  if (m && m[1]) {
                    encoding = m[1].toLowerCase();
                    if (encoding === 'utf-8') {
                      encoding = 'utf8';
                    }
                  }
                  if (!/^(text)|(application)\//.test(cType)) {
                    encoding = null;
                  }
                }
              } else {
                encoding = opts.resEncoding;
              }
              decode = function(buf) {
                var err;
                if (!encoding) {
                  return buf;
                }
                try {
                  if (encoding === 'utf8') {
                    return buf.toString();
                  } else {
                    return kit.requireOptional('iconv-lite').decode(buf, encoding);
                  }
                } catch (_error) {
                  err = _error;
                  return reject(err);
                }
              };
              if (opts.autoUnzip) {
                switch (res.headers['content-encoding']) {
                  case 'gzip':
                    unzip = kit.require('zlib').gunzip;
                    break;
                  case 'deflate':
                    unzip = kit.require('zlib').inflate;
                    break;
                  default:
                    unzip = null;
                }
                if (unzip) {
                  return unzip(buf, function(err, buf) {
                    return resolver(decode(buf));
                  });
                } else {
                  return resolver(decode(buf));
                }
              } else {
                return resolver(decode(buf));
              }
            } else {
              return resolver(buf);
            }
          });
        }
      });
      req.on('error', function(err) {
        var _ref;
        if ((_ref = opts.resPipe) != null) {
          _ref.end();
        }
        return reject(err);
      });
      if (opts.timeout > 0) {
        req.setTimeout(opts.timeout, function() {
          return req.emit('error', new Error('timeout'));
        });
      }
      if (opts.reqPipe) {
        if (opts.reqProgress) {
          (function() {
            var complete, total;
            total = +opts.headers['content-length'];
            complete = 0;
            return opts.reqPipe.on('data', function(chunk) {
              complete += chunk.length;
              return opts.reqProgress(complete, total);
            });
          })();
        }
        return opts.reqPipe.pipe(req);
      } else {
        if (opts.autoEndReq) {
          return req.end(reqBuf);
        }
      }
    });
    promise.req = req;
    return promise;
  },

  /**
  	 * A safer version of `child_process.spawn` to cross-platform run
  	 * a process. In some conditions, it may be more convenient
  	 * to use the `kit.exec`.
  	 * It will automatically add `node_modules/.bin` to the `PATH`
  	 * environment variable.
  	 * @param  {String} cmd Path or name of an executable program.
  	 * @param  {Array} args CLI arguments.
  	 * @param  {Object} opts Process options.
  	 * Same with the Node.js official documentation.
  	 * Except that it will inherit the parent's stdio.
  	 * @return {Promise} The `promise.process` is the spawned child
  	 * process object.
  	 * **Resolves** when the process's stdio is drained and the exit
  	 * code is either `0` or `130`. The resolve value
  	 * is like:
  	 * ```coffee
  	 * {
  	 * 	code: 0
  	 * 	signal: null
  	 * }
  	 * ```
  	 * @example
  	 * ```coffee
  	 * kit.spawn 'git', ['commit', '-m', '42 is the answer to everything']
  	 * .then ({code}) -> kit.log code
  	 * ```
   */
  spawn: function(cmd, args, opts) {
    var PATH, cmdSrc, m, promise, ps, spawn;
    if (args == null) {
      args = [];
    }
    if (opts == null) {
      opts = {};
    }
    PATH = process.env.PATH || process.env.Path;
    [kit.path.normalize(__dirname + '/../node_modules/.bin'), kit.path.normalize(process.cwd() + '/node_modules/.bin')].forEach(function(path) {
      if (PATH.indexOf(path) < 0 && kit.fs.existsSync(path)) {
        return PATH = [path, PATH].join(kit.path.delimiter);
      }
    });
    process.env.PATH = PATH;
    process.env.Path = PATH;
    _.defaults(opts, {
      stdio: 'inherit'
    });
    if (process.platform === 'win32') {
      cmd = kit.whichSync(cmd);
      if (cmd.slice(-3).toLowerCase() === 'cmd') {
        cmdSrc = kit.fs.readFileSync(cmd, 'utf8');
        m = cmdSrc.match(/node\s+"%~dp0\\(\.\.\\.+)"/);
        if (m && m[1]) {
          cmd = kit.path.join(cmd, '..', m[1]);
          cmd = kit.path.normalize(cmd);
          args = [cmd].concat(args);
          cmd = 'node';
        }
      }
    }
    spawn = kit.require('child_process').spawn;
    ps = null;
    promise = new Promise(function(resolve, reject) {
      var err;
      try {
        ps = spawn(cmd, args, opts);
      } catch (_error) {
        err = _error;
        reject(err);
      }
      ps.on('error', function(err) {
        return reject(err);
      });
      return ps.on('close', function(code, signal) {
        if (code === null || code === 0 || code === 130) {
          return resolve({
            code: code,
            signal: signal
          });
        } else {
          return reject({
            code: code,
            signal: signal
          });
        }
      });
    });
    promise.process = ps;
    return promise;
  },

  /**
  	 * Sequencing and executing tasks and dependencies concurrently.
  	 * @param  {String}   name The task name.
  	 * @param  {Object}   opts Optional. Defaults:
  	 * ```coffee
  	 * {
  	 * 	deps: String | Array
  	 * 	description: String
  	 * 	log: ->
  	 * 		kit.log 'Run Task >> '.cyan +
  	 * 			"[ #{name} ] ".green + this.description
  	 *
  	 * 	# Whether to run dependency in a row.
  	 * 	isSequential: false
  	 * }
  	 * ```
  	 * @param  {Function} fn `(val) -> Promise | Any` The task function.
  	 * If it is a async task, it should return a promise.
  	 * It will get its dependency tasks' resolved values.
  	 * @property {Function} run Use it to start tasks. Each task will only run once.
  	 * `(names = 'default', opts) ->`. The `names` can be a string or array.
  	 * The default opts:
  	 * ```coffee
  	 * {
  	 * 	isSequential: false
  	 *
  	 * 	# Will be passed as the first task's argument.
  	 * 	init: undefined
  	 *
  	 * 	# To stop the run currently in process. Set the `$stop`
  	 * 	# reference to true. It will reject a "runStopped" error.
  	 * 	flow: { $stop: false }
  	 * }
  	 * ```
  	 * @property {Object} list The defined task functions.
  	 * @return {Promise} Resolve with the last task's resolved value.
  	 * When `isSequential == true`, it resolves a value, else it resolves
  	 * an array.
  	 * @example
  	 * ```coffee
  	 * kit.task 'default', { deps: 'build' }, ->
  	 * 	kit.log 'run defaults...'
  	 *
  	 * kit.task 'build', { deps: ['clean'] }, (isFull) ->
  	 * 	if isFull
  	 * 		'do something'
  	 * 	else
  	 * 		'do something else'
  	 *
  	 * kit.task 'clean', (opts) ->
  	 * 	if opts.isForce
  	 * 		kit.remove 'dist/**', { isForce: true }
  	 * 	else
  	 * 		kit.remove 'dist/**'
  	 *
  	 * kit.task.run()
  	 * .then ->
  	 * 	kit.log 'All Done!'
  	 * ```
   */
  task: function(name, opts, fn) {
    var runTask, _base, _base1;
    if (_.isFunction(opts)) {
      fn = opts;
      opts = {};
    }
    _.defaults(opts, {
      isSequential: false,
      description: '',
      log: function() {
        return kit.log('Run Task >> '.cyan + ("[ " + name + " ] ").green + this.description);
      }
    });
    if (_.isString(opts.deps)) {
      opts.deps = [opts.deps];
    }
    if ((_base = kit.task).list == null) {
      _base.list = {};
    }
    runTask = function(flow) {
      return function(name) {
        return function(val) {
          if (flow[name]) {
            return flow[name];
          } else {
            return flow[name] = kit.task.list[name](flow)(val);
          }
        };
      };
    };
    kit.task.list[name] = function(flow) {
      return function(val) {
        var depTasks;
        if (flow.$stop) {
          return Promise.reject(new Error('runStopped'));
        }
        opts.log();
        if (!opts.deps || opts.deps.length < 1) {
          return Promise.resolve(fn(val));
        }
        depTasks = opts.deps.map(runTask(flow));
        return (opts.isSequential ? kit.compose(depTasks)(val) : Promise.all(depTasks.map(function(task) {
          return task(val);
        }))).then(fn);
      };
    };
    kit.task.list[name].opts = opts;
    return (_base1 = kit.task).run != null ? _base1.run : _base1.run = function(names, opts) {
      var task;
      if (names == null) {
        names = 'default';
      }
      if (opts == null) {
        opts = {};
      }
      if (_.isString(names)) {
        names = [names];
      }
      _.defaults(opts, {
        isSequential: false,
        init: void 0,
        flow: {
          $stop: false
        }
      });
      task = runTask(opts.flow);
      if (opts.isSequential) {
        return kit.compose(names.map(task))(opts.init);
      } else {
        return Promise.all(names.map(function(name) {
          return task(name)(opts.init);
        }));
      }
    };
  },

  /**
  	 * Node native module `url`.
   */
  url: require('url'),

  /**
  	 * Same as the unix `which` command.
  	 * @type {Function}
   */
  which: fs.promisify(which),

  /**
  	 * Sync version of `which`.
  	 * @type {Function}
   */
  whichSync: which.sync
});

if (kit.isDevelopment()) {
  Promise.longStackTraces();
} else {
  colors.mode = 'none';
}

module.exports = kit;
