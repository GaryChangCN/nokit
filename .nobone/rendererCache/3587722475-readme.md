<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="assets/markdown/sh/shCoreDefault.css?noboneAssets">
	<link rel="stylesheet" type="text/css" href="assets/markdown/default.css?noboneAssets">

	<title>Nobone - /Users/ys/Cosmos/Cradle/Vane/nokit/readme.md</title>
</head>
<body>

<div id="main">
	<div>
		<h1 id="overview">Overview</h1>
<p>A light weight set of handy tools for real world program.</p>
<p>Reduce the gap between different systems. Such as watch directory changes on a network file system, operate <code>spawn</code> on Windows and Linux, handle async IO api with promise, etc.</p>
<p>Rather than help you decide what to do, it is designed to create possibilities. Even this document is generated by nokit itself.</p>
<p>It&#39;s one of the core lib of <a href="https://github.com/ysmood/nobone">nobone</a>.</p>
<p><a href="http://badge.fury.io/js/nokit"><img src="https://badge.fury.io/js/nokit.svg" alt="NPM version"></a> <a href="https://travis-ci.org/ysmood/nokit"><img src="https://travis-ci.org/ysmood/nokit.svg" alt="Build Status"></a> <a href="https://ci.appveyor.com/project/ysmood/nokit"><img src="https://ci.appveyor.com/api/projects/status/github/ysmood/nokit?svg=true" alt="Build status"></a> <a href="https://david-dm.org/ysmood/nokit"><img src="https://david-dm.org/ysmood/nokit.svg?style=flat" alt="Deps Up to Date"></a></p>
<h2 id="features">Features</h2>
<ul>
<li>All async functions will return promise.</li>
<li>All functions are highly lazy designed, minimum boot time.</li>
<li>Test on Node 0.8 - 0.12 on Mac, Linux and Windows.</li>
<li>Light weight and self-reference.</li>
</ul>
<h1 id="installation">Installation</h1>
<p>As a lib dependency, install it locally: <code>npm i nokit</code>.</p>
<p>Nokit has provided a cli tool like GNU Make. If you install it globally like this:</p>
<p><code>npm -g i nokit</code></p>
<p>, then have fun with your <code>nofile</code>, it can be js, coffee, babeljs or livescript. For more information goto the <code>CLI</code> section.</p>
<h2 id="cli">CLI</h2>
<p>By default nokit only supports js, if you want nokit to support coffee, you should install nokit like this:</p>
<p><code>npm i -g nokit coffee-script</code></p>
<p>Same works with babeljs:</p>
<p><code>npm i -g nokit babel</code></p>
<blockquote>
<p>Remarks: for the sake of boot performance, nokit will only try to load
<code>coffee-script/register</code> and <code>babeljs/register</code>
by default. For livescript or other precompiler, you have to
set environment varialbe <code>nokitPreload</code> to what you want, such as on unix:
<code>export nokitPreload=&#39;livescript coffee-script/register&#39;</code>. Different module
names are separated by spaces.</p>
</blockquote>
<p>Create a <code>nofile.coffee</code> (or <code>.js</code>, <code>.ls</code>) at your current working directory
or any of its parents directory. The syntax of <code>nofile</code> is almost the same as the Cakefile, only the <code>option</code>&#39;s first argument is slightly changed.</p>
<p>Assume your file content is:</p>
<pre><code class="lang-coffee">module.exports = (task, option) -&gt;
    kit = require &#39;nokit&#39;

    option &#39;-w, --hello [world]&#39;, &#39;Just a test option&#39;, &#39;&#39;

    # Define a default task, and it depends on the &quot;clean&quot; task.
    task &#39;default&#39;, [&#39;clean&#39;], &#39;This is a comment info&#39;, (opts) -&gt;
        kit.log opts.hello

        # Use colors.
        kit.require &#39;colors&#39;
        kit.log &#39;print red words&#39;.red

    task &#39;clean&#39;, -&gt;
        kit.remove &#39;dist&#39;

    # To add alias to a task, just use space to separate names.
    # Here &#39;build&#39; and &#39;b&#39; are the same task.
    task &#39;build b&#39;, -&gt;
        kit.require &#39;drives&#39;
        kit.warp &#39;src/**/*.js&#39;
        .load kit.drives.auto &#39;compile&#39;
        .run &#39;dist&#39;

    task &#39;sequential&#39;, [&#39;clean&#39;, &#39;build&#39;], true, -&gt;
        kit.log &#39;Run clean and build non-concurrently.&#39;
</code></pre>
<p>Then you can run it in command line: <code>no</code>. Just that simple, without task
name, <code>no</code> will try to call the <code>default</code> task directly.</p>
<p>You can run <code>no -h</code> to display help info.</p>
<p>Call <code>no build</code> or <code>no b</code> to run the <code>build</code> task.</p>
<p>For real world example, just see the <a href="nofile.coffee?source">nofile</a> that nokit is using.</p>
<p>For more doc for the <code>option</code> goto <a href="https://github.com/tj/commander.js">commander.js</a>.</p>
<h1 id="changelog">Changelog</h1>
<p>Goto <a href="doc/changelog.md">changelog</a></p>
<h1 id="api">API</h1>
<ul>
<li><h2 id="-overview-lib-kit-coffee-source-l30-"><strong><a href="lib/kit.coffee?source#L30">Overview</a></strong></h2>
<p>  Nokit extends all the functions of <a href="https://github.com/ysmood/nofs">nofs</a>
  and <a href="https://github.com/ysmood/yaku#utils"><code>yaku/lib/utils</code></a>.
  You can use it as same as nofs. For more info, see the doc:</p>
<p>  <a href="?gotoDoc=nofs/readme.md">Offline Documentation</a></p>
<ul>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.readFile(&#39;test.txt&#39;, &#39;utf8&#39;).then (str) -&gt;
      console.log str

  kit.outputFile &#39;a.txt&#39;, &#39;test&#39;
  .then -&gt; kit.log &#39;done&#39;

  kit.writeJSON &#39;b.json&#39;, { a: 10 }
  .then -&gt; kit.log &#39;done&#39;

  kit.mkdirs &#39;b.json&#39;, { a: 10 }
  .then -&gt; kit.log &#39;done&#39;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-_-lib-kit-coffee-source-l42-"><strong><a href="lib/kit.coffee?source#L42">_</a></strong></h2>
<p>  The <a href="https://lodash.com">lodash</a> lib.</p>
<ul>
<li><p><strong><u>type</u></strong>: { <em>Object</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit._.map [1, 2, 3]
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-browserhelper-opts-usejs-lib-kit-coffee-source-l70-"><strong><a href="lib/kit.coffee?source#L70">browserHelper(opts, useJs)</a></strong></h2>
<p>  The browser helper. It helps you to live reload the page and log remotely.</p>
<ul>
<li><p><strong><u>static</u></strong>:</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  The options of the client, defaults:</p>
<pre><code class="lang-coffee">  {
      host: &#39;&#39; # The host of the event source.
  }
</code></pre>
</li>
<li><p><strong><u>param</u></strong>: <code>useJs</code> { <em>Boolean</em> }</p>
<p>  By default use html. Default is false.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>String</em> }</p>
<p>  The code of client helper.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<p>  When the client code is loaded on the browser, you can use
  the <code>nb.log</code> to log anything to server&#39;s terminal.
  The server will auto-format and log the information to the terminal.
  It&#39;s convinient for mobile development when remote debug is not possible.</p>
<pre><code class="lang-coffee">  # The nb is assigned to the &quot;window&quot; object.
  nb.log { a: 10 }
  nb.log 10
  nb.es.addEventListener &#39;fileModified&#39;, -&gt;
      console.log &#39;file changed&#39;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-colors-lib-kit-coffee-source-l104-"><strong><a href="lib/kit.coffee?source#L104">colors</a></strong></h2>
<p>  The <a href="https://github.com/Marak/colors.js">colors</a> lib
  makes it easier to print colorful info in CLI.
  You must <code>kit.require &#39;colors&#39;</code> before using it.
  Sometimes use <code>kit.require &#39;colors/safe&#39;</code> will be better.</p>
<ul>
<li><p><strong><u>type</u></strong>: { <em>Object</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  cs = kit.require &#39;colors/safe&#39;
  kit.log cs.red &#39;error info&#39;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-depscache-info-lib-kit-coffee-source-l154-"><strong><a href="lib/kit.coffee?source#L154">depsCache(info)</a></strong></h2>
<p>  A fast file cache helper. It uses hard link to cache files.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>info</code> { <em>Object</em> }</p>
<p>  Not optional.</p>
<pre><code class="lang-coffee">  {
      # The first item is the key path, others are
      # its dependencies.
      deps: Array

      # The path of the output file.
      # If it&#39;s undefined, depsCache will try to get cache.
      dests: Array

      cacheDir: &#39;.nokit&#39;
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  Resolve a info object.</p>
<pre><code class="lang-coffee">  {
      isNewer: Boolean

      # { path: mtime }
      deps: Object

      # { destPath: cachePath }
      dests: Object

      cacheError: undefined | Error
  }
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  # Set cache
  kit.depsCache {
      dests: [&#39;index.css&#39;]
      deps: [&#39;index.less&#39;, &#39;b.less&#39;, &#39;c.less&#39;]
  }

  # Get cache
  # You don&#39;t have to sepecify &#39;b.less&#39;, &#39;c.less&#39;.
  kit.depsCache { deps: [&#39;index.less&#39;] }
  .then (cache) -&gt;
      if cache.isNewer
          kit.log &#39;cache is newer&#39;.
          kit.log cache.dests
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-daemonize-opts-lib-kit-coffee-source-l236-"><strong><a href="lib/kit.coffee?source#L236">daemonize(opts)</a></strong></h2>
<p>  Daemonize a program. Just a shortcut usage of <code>kit.spawn</code>.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      bin: &#39;node&#39;
      args: [&#39;app.js&#39;]
      stdout: &#39;stdout.log&#39; # Can also be a fd
      stderr: &#39;stderr.log&#39; # Can also be a fd
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Porcess</em> }</p>
<p>  The daemonized process.</p>
</li>
</ul>
</li>
<li><h2 id="-decrypt-data-password-algorithm-lib-kit-coffee-source-l263-"><strong><a href="lib/kit.coffee?source#L263">decrypt(data, password, algorithm)</a></strong></h2>
<p>  A simple decrypt helper. Cross-version of node.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>data</code> { <em>Any</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>password</code> { <em>String | Buffer</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>algorithm</code> { <em>String</em> }</p>
<p>  Default is &#39;aes128&#39;.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Buffer</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-drives-lib-kit-coffee-source-l285-"><strong><a href="lib/kit.coffee?source#L285">drives</a></strong></h2>
<p>  The warp drives.
  You must <code>kit.require &#39;drives&#39;</code> before using it.
  For more information goto the <code>Drives</code> section.</p>
<ul>
<li><strong><u>type</u></strong>: { <em>Object</em> }</li>
</ul>
</li>
<li><h2 id="-encrypt-data-password-algorithm-lib-kit-coffee-source-l294-"><strong><a href="lib/kit.coffee?source#L294">encrypt(data, password, algorithm)</a></strong></h2>
<p>  A simple encrypt helper. Cross-version of node.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>data</code> { <em>Any</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>password</code> { <em>String | Buffer</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>algorithm</code> { <em>String</em> }</p>
<p>  Default is &#39;aes128&#39;.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Buffer</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-err-msg-opts-lib-kit-coffee-source-l315-"><strong><a href="lib/kit.coffee?source#L315">err(msg, opts)</a></strong></h2>
<p>  A error log shortcut for <code>kit.log(msg, &#39;error&#39;, opts)</code></p>
<ul>
<li><p><strong><u>param</u></strong>: <code>msg</code> { <em>Any</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-exec-cmd-shell-lib-kit-coffee-source-l353-"><strong><a href="lib/kit.coffee?source#L353">exec(cmd, shell)</a></strong></h2>
<p>  A better <code>child_process.exec</code>. Supports multi-line shell script.
  For supporting old version of node, it will create 3 temp files,
  the temp files will be removed after the execution.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>cmd</code> { <em>String</em> }</p>
<p>  Shell commands.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>shell</code> { <em>String</em> }</p>
<p>  Shell name. Such as <code>bash</code>, <code>zsh</code>. Optinal.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  Resolves when the process&#39;s stdio is drained.
  The resolve value is like:</p>
<pre><code class="lang-coffee">  {
      code: 0
      signal: null
      stdout: &#39;hello world&#39;
      stderr: &#39;&#39;
  }
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.exec(&quot;&quot;&quot;
      a=&#39;hello world&#39;
   echo $a
  &quot;&quot;&quot;).then ({code, stdout}) -&gt;
      kit.log code # output =&gt; 0
      kit.log stdout # output =&gt; &quot;hello world&quot;

  # Bash doesn&#39;t support &quot;**&quot; recusive match pattern.
  p = kit.exec &quot;&quot;&quot;
      echo **/*.css
  &quot;&quot;&quot;, &#39;zsh&#39;

  # Get the child process object.
  p.process.then (proc) -&gt;
      kit.log proc.pid
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-formatcomment-comments-opts-lib-kit-coffee-source-l423-"><strong><a href="lib/kit.coffee?source#L423">formatComment(comments, opts)</a></strong></h2>
<p>  Format the parsed comments array to a markdown string.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>comments</code> { <em>Array</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      indent: 0
      name: ({ name }) -&gt;
          name = name.replace &#39;self.&#39;, &#39;&#39;
          &quot;- \#\#\#\# #{name}\n\n&quot;
      tag: ({ tagName, name, type }) -&gt;
          tname = if name then &quot; `#{name}`&quot; else &#39;&#39;
          ttype = if type then &quot; { _#{type}_ }&quot; else &#39;&#39;
          &quot;- **&lt;u&gt;#{tagName}&lt;/u&gt;**:#{tname}#{ttype}&quot;
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>String</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-fs-lib-kit-coffee-source-l476-"><strong><a href="lib/kit.coffee?source#L476">fs</a></strong></h2>
<p>  See my project <a href="https://github.com/ysmood/nofs">nofs</a>.</p>
<p>  <a href="?gotoDoc=nofs/readme.md">Offline Documentation</a></p>
</li>
<li><h2 id="-fuzzysearch-keys-list-opts-lib-kit-coffee-source-l517-"><strong><a href="lib/kit.coffee?source#L517">fuzzySearch(keys, list, opts)</a></strong></h2>
<p>  Fuzzy search a string list by a key word.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>keys</code> { <em>String</em> }</p>
<p>  The key word.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>list</code> { <em>Array</em> }</p>
<p>  The list of string to search.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      result: (wrappedList) -&gt;
          wrappedList.min(&#39;distance&#39;).words
      threshold: (cOffset, keyLen, cIndex) -&gt;
          Infinity
      notFound: (cOffset, keyLen, cIndex) -&gt;
          Infinity
      span: (cOffset, keyLen, cIndex) -&gt;
          cOffset
      found: (cOffset, keyLen, cIndex) -&gt;
          (Math.exp(cOffset + 1) - 1) * (keyLen - cIndex)
      tail: (cOffset, keyLen, cIndex, tailLen) -&gt;
          tailLen
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>String</em> }</p>
<p>  The best matched one. If not found,
  return undefined.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.fuzzySearch &#39;hw&#39;, [&#39;test&#39;, &#39;hello world&#39;, &#39;hey world&#39;]
  # output =&gt; &#39;hey world&#39;

  # To get a sortable weighted list.
  kit.fuzzySearch &#39;hw&#39;, [&#39;test&#39;, &#39;hello world&#39;, &#39;hey world&#39;], {
      result: (wrappedList) -&gt; wrappedList.value()
  }
  # output =&gt; [
  #  { distance: Infinity }
  #  { words: &#39;hello world&#39;, distance: 1110.069 }
  #  { words: &#39;hey world&#39;, distance: 159.849 }
  # ]
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-genmodulepaths-modulename-dir-moddir-lib-kit-coffee-source-l571-"><strong><a href="lib/kit.coffee?source#L571">genModulePaths(moduleName, dir, modDir)</a></strong></h2>
<p>  Generate a list of module paths from a name and a directory.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>moduleName</code> { <em>String</em> }</p>
<p>  The module name.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>dir</code> { <em>String</em> }</p>
<p>  The root path. Default is current working dir.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>modDir</code> { <em>String</em> }</p>
<p>  Default is &#39;node_modules&#39;.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Array</em> }</p>
<p>  Paths</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  # Suppose current working directory is &#39;/home/a&#39;
  kit.genModulePaths &#39;test&#39;
  # output =&gt; [&#39;/home/a/node_modules/test&#39;, &#39;/home/node_modules/test&#39;, &#39;/node_modules/test&#39;]
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-indent-text-num-char-reg-lib-kit-coffee-source-l601-"><strong><a href="lib/kit.coffee?source#L601">indent(text, num, char, reg)</a></strong></h2>
<p>  Indent a text block.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>text</code> { <em>String</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>num</code> { <em>Int</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>char</code> { <em>String</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>reg</code> { <em>RegExp</em> }</p>
<p>  Default is <code>/^/mg</code>.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>String</em> }</p>
<p>  The indented text block.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  # Increase
  kit.indent &quot;one\ntwo&quot;, 2
  # =&gt; &quot;  one\n  two&quot;

  # Decrease
  kit.indent &quot;--one\n--two&quot;, 0, &#39;&#39;, /^--/mg
  # =&gt; &quot;one\ntwo&quot;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-isdevelopment-lib-kit-coffee-source-l611-"><strong><a href="lib/kit.coffee?source#L611">isDevelopment()</a></strong></h2>
<p>  Nokit use it to check the running mode of the app.
  Overwrite it if you want to control the check logic.
  By default it returns the <code>rocess.env.NODE_ENV == &#39;development&#39;</code>.</p>
<ul>
<li><strong><u>return</u></strong>: { <em>Boolean</em> }</li>
</ul>
</li>
<li><h2 id="-isproduction-lib-kit-coffee-source-l620-"><strong><a href="lib/kit.coffee?source#L620">isProduction()</a></strong></h2>
<p>  Nokit use it to check the running mode of the app.
  Overwrite it if you want to control the check logic.
  By default it returns the <code>rocess.env.NODE_ENV == &#39;production&#39;</code>.</p>
<ul>
<li><strong><u>return</u></strong>: { <em>Boolean</em> }</li>
</ul>
</li>
<li><h2 id="-jhash-lib-kit-coffee-source-l645-"><strong><a href="lib/kit.coffee?source#L645">jhash</a></strong></h2>
<p>  A fast helper to hash string or binary file.
  See my <a href="https://github.com/ysmood/jhash">jhash</a> project.
  You must <code>kit.require &#39;jhash&#39;</code> before using it.</p>
<p>  <a href="?gotoDoc=jhash/readme.md">Offline Documentation</a></p>
<ul>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.require &#39;jhash&#39;
  kit.jhash.hash &#39;test&#39; # output =&gt; &#39;349o&#39;

  jhash.hash kit.readFileSync(&#39;a.jpg&#39;)

  # Control the hash char set.
  kit.jhash.setSymbols &#39;abcdef&#39;
  kit.jhash.hash &#39;test&#39; # output =&gt; &#39;decfddfe&#39;

  # Control the max length of the result hash value. Unit is bit.
  jhash.setMaskLen 10
  jhash.hash &#39;test&#39; # output =&gt; &#39;ede&#39;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-ken-lib-kit-coffee-source-l652-"><strong><a href="lib/kit.coffee?source#L652">ken</a></strong></h2>
<p>  The <code>ken</code> module.
  You must <code>kit.require &#39;ken&#39;</code> before using it.
  For more information goto the <code>Ken</code> section.</p>
</li>
<li><h2 id="-log-msg-action-opts-lib-kit-coffee-source-l691-"><strong><a href="lib/kit.coffee?source#L691">log(msg, action, opts)</a></strong></h2>
<p>  A better log for debugging, it uses the <code>kit.xinspect</code> to log.</p>
<p>  Use terminal command like <code>logReg=&#39;pattern&#39; node app.js</code> to
  filter the log info.</p>
<p>  Use <code>logTrace=&#39;on&#39; node app.js</code> to force each log end with a
  stack trace.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>msg</code> { <em>Any</em> }</p>
<p>  Your log message.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>action</code> { <em>String</em> }</p>
<p>  &#39;log&#39;, &#39;error&#39;, &#39;warn&#39;.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Default is same with <code>kit.xinspect</code>,
  but with some extra options:</p>
<pre><code class="lang-coffee">  {
      isShowTime: true
      logReg: process.env.logReg and new RegExp process.env.logReg
      logTrace: process.env.logTrace == &#39;on&#39;

      # Custom log method
      log: (str, action) -&gt; console[action] str
  }
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.log &#39;test&#39;
  # =&gt; &#39;[2015-02-07 08:31:49] test&#39;

  kit.log &#39;test&#39;, { isShowTime: false }
  # =&gt; &#39;test&#39;

  kit.log &#39;test&#39;, { logReg: /a/ }
  # =&gt; &#39;&#39;

  kit.log &#39;%s %s %d&#39;, [&#39;a&#39;, &#39;b&#39;, 10]
  # =&gt; &#39;[2015-02-07 08:31:49] a b 10&#39;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-logs-args-lib-kit-coffee-source-l781-"><strong><a href="lib/kit.coffee?source#L781">logs(args)</a></strong></h2>
<p>  Shortcut for logging multiple strings.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>args</code> { <em>Any</em> }</p>
<p>  ...</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.log &#39;test1&#39;, &#39;test2&#39;, test3&#39;
  # =&gt; [2015-02-07 08:31:49] test1 test2 test3
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-monitorapp-opts-lib-kit-coffee-source-l855-"><strong><a href="lib/kit.coffee?source#L855">monitorApp(opts)</a></strong></h2>
<p>  Monitor an application and automatically restart it when file changed.
  Even when the monitored app exit with error, the monitor will still wait
  for your file change to restart the application. Not only nodejs, but also
  other programs like ruby or python.
  It will print useful infomation when it application unexceptedly.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      bin: &#39;node&#39;
      args: [&#39;index.js&#39;]
      watchList: [] # By default, the same with the &quot;args&quot;.
      isNodeDeps: true
      opts: {} # Same as the opts of &#39;kit.spawn&#39;.

      # The option of `kit.parseDependency`
      parseDependency: {}

      onStart: -&gt;
          kit.log &quot;Monitor: &quot; + opts.watchList
      onRestart: (path) -&gt;
          kit.log &quot;Reload app, modified: &quot; + path
      onWatchFiles: (paths) -&gt;
          kit.log &#39;Watching:&#39; + paths.join(&#39;, &#39;)
      onNormalExit: ({ code, signal }) -&gt;
          kit.log &#39;EXIT&#39; +
              &quot; code: #{code} signal: #{signal}&quot;
      onErrorExit: ({ code, signal }) -&gt;
          kit.err &#39;EXIT&#39; +
          &quot; code: #{code} signal: #{signal}\n&quot; +
          &#39;Process closed. Edit and save
              the watched file to restart.&#39;
      sepLine: -&gt;
          process.stdout.write _.repeat(&#39;*&#39;, process.stdout.columns)
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  It has a property <code>process</code>, which is the monitored
  child process. Properties:</p>
<pre><code class="lang-coffee">  {
      process: Object

      # Call it to stop monitor.
      stop: -&gt;

      # Resolve a list of watch handlers.
      watchPromise: Promise
  }
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.monitorApp {
      bin: &#39;coffee&#39;
      args: [&#39;main.coffee&#39;]
  }

  kit.monitorApp {
      bin: &#39;ruby&#39;
      args: [&#39;app.rb&#39;, &#39;lib/**/*.rb&#39;]
      isNodeDeps: false
  }
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-nodeversion-lib-kit-coffee-source-l951-"><strong><a href="lib/kit.coffee?source#L951">nodeVersion()</a></strong></h2>
<p>  Node version. Such as <code>v0.10.23</code> is <code>0.1023</code>, <code>v0.10.1</code> is <code>0.1001</code>.</p>
<ul>
<li><strong><u>return</u></strong>: { <em>Float</em> }</li>
</ul>
</li>
<li><h2 id="-defaultargs-args-defaults-lib-kit-coffee-source-l981-"><strong><a href="lib/kit.coffee?source#L981">defaultArgs(args, defaults)</a></strong></h2>
<p>  A helper for arguments type based function override.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>args</code> { <em>Array | Object</em> }</p>
<p>  The arguments to set.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>defaults</code> { <em>Object</em> }</p>
<p>  The default argument settings.
  The key value of the setting is the argument name, the value
  is an object, and the key is the type of the argument, the
  value is the default value of the argument.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Object</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  foo = -&gt;
      args = kit.defaultArgs arguments, {
          name: { String: &#39;A&#39; }
          colors: { Array: [] }
          family: { String: null }
          isReal: { Boolean: false }
          fn: { Function: -&gt; &#39;callback&#39; }
      }

  kit.log foo(&#39;test&#39;, false, [&#39;red&#39;], -&gt; &#39;nothing&#39;)
  # Here the logged value will deeply equal:
  { name: &#39;test&#39;, colors: [&#39;red&#39;], family: null, fn: -&gt; &#39;nothing&#39; }
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-parsecomment-code-opts-lib-kit-coffee-source-l1031-"><strong><a href="lib/kit.coffee?source#L1031">parseComment(code, opts)</a></strong></h2>
<p>  A comments parser for javascript and coffee-script.
  Used to generate documentation from source code automatically.
  It will traverse through all the comments of a coffee file.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>code</code> { <em>String</em> }</p>
<p>  Coffee source code.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Parser options:</p>
<pre><code class="lang-coffee">  {
      commentReg: RegExp
      splitReg: RegExp
      tagNameReg: RegExp
      typeReg: RegExp
      nameReg: RegExp
      nameTags: [&#39;param&#39;, &#39;property&#39;]
      descriptionReg: RegExp
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Array</em> }</p>
<p>  The parsed comments. Each item is something like:</p>
<pre><code class="lang-coffee">  {
      name: &#39;parseComment&#39;
      description: &#39;A comments parser for coffee-script.&#39;
      tags: [
          {
              tagName: &#39;param&#39;
              type: &#39;string&#39;
              name: &#39;code&#39;
              description: &#39;The name of the module it belongs to.&#39;
              index: 256 # The target char index in the file.
              line: 32 # The line number of the target in the file.
          }
      ]
  }
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-parsedependency-entrypaths-opts-lib-kit-coffee-source-l1134-"><strong><a href="lib/kit.coffee?source#L1134">parseDependency(entryPaths, opts)</a></strong></h2>
<p>  Parse dependency tree by regex. The dependency relationships
  is not a tree, but a graph. To avoid dependency cycle, this
  function only return an linear array of the dependencies,
  from which you won&#39;t get the detail relationshops between files.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>entryPaths</code> { <em>String | Array</em> }</p>
<p>  The file to begin with.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      depReg: /require\s*\(?[&#39;&quot;](.+)[&#39;&quot;]\)?/gm
      depRoots: [&#39;&#39;]
      extensions: [&#39;.js&#39;, &#39;.coffee&#39;, &#39;index.js&#39;, &#39;index.coffee&#39;]

      # It will handle all the matched paths.
      # Return false value if you don&#39;t want this match.
      handle: (path) -&gt;
          path.replace(/^[\s&#39;&quot;]+/, &#39;&#39;).replace(/[\s&#39;&quot;;]+$/, &#39;&#39;)
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  It resolves the dependency path array.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.parseDependency &#39;main.&#39;, {
      depReg: /require\s*\(?[&#39;&quot;](.+)[&#39;&quot;]\)?/gm
      handle: (path) -&gt;
          return path if path.match /^(?:\.|/|[a-z]:)/i
  }
  .then (markdownStr) -&gt;
      kit.log markdownStr
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-path-lib-kit-coffee-source-l1197-"><strong><a href="lib/kit.coffee?source#L1197">path</a></strong></h2>
<p>  io.js native module <code>path</code>. See <code>nofs</code> for more information.</p>
</li>
<li><h2 id="-promise-lib-kit-coffee-source-l1205-"><strong><a href="lib/kit.coffee?source#L1205">Promise</a></strong></h2>
<p>  The promise lib. Now, it uses Yaku as ES5 polyfill.
  In the future, the Yaku will be replaced with native
  ES6 Promise. Please don&#39;t use any API other than the ES6 spec.</p>
<ul>
<li><strong><u>type</u></strong>: { <em>Object</em> }</li>
</ul>
</li>
<li><h2 id="-proxy-lib-kit-coffee-source-l1212-"><strong><a href="lib/kit.coffee?source#L1212">proxy</a></strong></h2>
<p>  The <code>proxy</code> module.
  You must <code>kit.require &#39;proxy&#39;</code> before using it.
  For more information goto the <code>Proxy</code> section.</p>
</li>
<li><h2 id="-regexreduce-reg-str-iter-init-lib-kit-coffee-source-l1231-"><strong><a href="lib/kit.coffee?source#L1231">regexReduce(reg, str, iter, init)</a></strong></h2>
<p>  Reduce a string via a regex.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>reg</code> { <em>RegExp</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>str</code> { <em>String</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>iter</code> { <em>Function</em> }</p>
<p>  <code>(init, matchGroup) -&gt; init</code>, default is <code>_.iteratee</code>.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>init</code> { <em>Any</em> }</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Any</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  out = kit.regexReduce /\w(\d+)/g, &#39;a1, b10, c3&#39;, (ret, ms) -&gt;
      ret.push ms[1]
      ret
  , []

  kit.log out # =&gt; [1, 10, 3]
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-regexmap-reg-str-iter-lib-kit-coffee-source-l1255-"><strong><a href="lib/kit.coffee?source#L1255">regexMap(reg, str, iter)</a></strong></h2>
<p>  Map a string via a regex.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>reg</code> { <em>RegExp</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>str</code> { <em>String</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>iter</code> { <em>Function</em> }</p>
<p>  <code>(matchGroup) -&gt;</code>, default is <code>_.iteratee</code>.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Array</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  out = kit.regexMap /\w(\d+)/g, &#39;a1, b10, c3&#39;, 1

  kit.log out # =&gt; [1, 10, 3]
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-require-modulename-dir-loaded-lib-kit-coffee-source-l1293-"><strong><a href="lib/kit.coffee?source#L1293">require(moduleName, dir, loaded)</a></strong></h2>
<p>  Much faster than the native require of node, but you should
  follow some rules to use it safely.
  Use it to load nokit&#39;s internal module.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>moduleName</code> { <em>String</em> }</p>
<p>  The module path or name.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>dir</code> { <em>String</em> }</p>
<p>  Current absolute file path. Not optional, expect when
  requiring nokit&#39;s internal modules.
  On most times, just pass <code>__dirname</code> to it is enough.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>loaded</code> { <em>Function</em> }</p>
<p>  Run only the first time after the module loaded.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Module</em> }</p>
<p>  The module that you require.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<p>  Use it to load nokit&#39;s internal module.</p>
<pre><code class="lang-coffee">  kit.require &#39;jhash&#39;
  # Then you can use the module, or it will be null.
  kit.jhash.hash &#39;test&#39;
</code></pre>
<p>  To load a relative path, or you own module,
  the second parameter &#39;dir&#39; is required.</p>
<pre><code class="lang-coffee">  mod = kit.require &#39;./mod&#39;, __dirname

  # Or load your own &#39;jhash&#39;, rather than nokit&#39;s.
  jhash = kit.require &#39;jhash&#39;, __dirname
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-requireoptional-name-dir-semver-lib-kit-coffee-source-l1365-"><strong><a href="lib/kit.coffee?source#L1365">requireOptional(name, dir, semver)</a></strong></h2>
<p>  Require an optional package. If not found, it will
  warn the user to npm install it, and exit the process.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>name</code> { <em>String</em> }</p>
<p>  Package name</p>
</li>
<li><p><strong><u>param</u></strong>: <code>dir</code> { <em>String</em> }</p>
<p>  Current absolute file path. Not optional.
  On most times, just pass <code>__dirname</code> to it is enough.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>semver</code> { <em>String</em> }</p>
<p>  Specify what version you need,
  such as <code>^0.3.1</code> or <code>&gt;=1.2.3</code>, ect.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Any</em> }</p>
<p>  The required package.</p>
</li>
</ul>
</li>
<li><h2 id="-request-opts-lib-kit-coffee-source-l1499-"><strong><a href="lib/kit.coffee?source#L1499">request(opts)</a></strong></h2>
<p>  A handy extended combination of <code>http.request</code> and <code>https.request</code>.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  The same as the <a href="http://nodejs.org/api/http.html#httpHttpRequestOptionsCallback">http.request</a>,
  but with some extra options:</p>
<pre><code class="lang-coffee">  {
      # String or Url Object.
      url: String | Object

      # Other than return `res` with `res.body`,return `body` directly.
      body: true

      # Max times of auto redirect. If 0, no auto redirect.
      redirect: 0

      # Timeout of the socket of the http connection.
      # If timeout happens, the promise will reject.
      # Zero means no timeout.
      timeout: 0

      # The key of headers should be lowercased.
      headers: {}

      protocol: &#39;http:&#39; or &#39;https:&#39;

      agent: null

      # Set &quot;transfer-encoding&quot; header to &#39;chunked&#39;.
      setTE: false

      # Set null to use buffer, optional.
      # It supports GBK, ShiftJIS etc.
      # For more info, see https://github.com/ashtuchkin/iconv-lite
      resEncoding: &#39;auto&#39;

      # It&#39;s string, object, stream or buffer, it&#39;s optional. When it&#39;s an object,
      # The request will be &#39;application/x-www-form-urlencoded&#39;.
      reqData: null

      # auto end the request.
      autoEndReq: true

      # Writable stream.
      resPipe: null

      # Handle resPipe before it&#39;s piped.
      # Its returned value will be assigned to `opts.resPipe`. So you can return
      # null to make the request resolve the `body`.
      handleResPipe: (res, resPipe) -&gt; resPipe

      # The progress of the request.
      reqProgress: (complete, total) -&gt;

      # The progress of the response.
      resProgress: (complete, total) -&gt;

      resPipeError: (res) -&gt; res.end()
  }
</code></pre>
<p>  And if set opts as string, it will be treated as the url.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  Contains the http response object,
  it has an extra <code>body</code> property.
  You can also get the request object by using <code>Promise.req</code>.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  p = kit.request &#39;http://test.com&#39;
  p.req.on &#39;response&#39;, (res) -&gt;
      kit.log res.headers[&#39;content-length&#39;]
  p.then (body) -&gt;
      kit.log body # html or buffer

  kit.request {
      url: {
          protocol: &#39;https&#39;, hostname: &#39;test.com&#39;
          port: 8123, path: &#39;/a.mp3?s=1&#39;
      }
      body: false
      resProgress: (complete, total) -&gt;
          kit.log &quot;Progress: #{complete} / #{total}&quot;
  }
  .then (res) -&gt;
      kit.log res.body.length
      kit.log res.headers

  # Send form-data.
  form = new (require &#39;form-data&#39;)
  form.append &#39;image&#39;, new Buffer(0), {
      filename: &#39;a.jpg&#39;, contentType: &#39;image/jpg&#39;
  }
  form.append &#39;key&#39;, &#39;value&#39;
  kit.request {
      url: &#39;a.com&#39;
      method: &#39;POST&#39;
      headers: form.getHeaders()

      # Use chunked encoding, so that we don&#39;t have to calculate
      # the &#39;Content-Length&#39;.
      setTE: true

      reqData: form
  }
  .then (body) -&gt;
      kit.log body
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-semver-lib-kit-coffee-source-l1709-"><strong><a href="lib/kit.coffee?source#L1709">semver</a></strong></h2>
<p>  The semantic versioner for npm, known as <a href="https://github.com/npm/node-semver">semver</a>.
  You must <code>kit.require &#39;semver&#39;</code> before using it.</p>
<ul>
<li><strong><u>type</u></strong>: { <em>Object</em> }</li>
</ul>
</li>
<li><h2 id="-spawn-cmd-args-opts-lib-kit-coffee-source-l1740-"><strong><a href="lib/kit.coffee?source#L1740">spawn(cmd, args, opts)</a></strong></h2>
<p>  A safer version of <code>child_process.spawn</code> to cross-platform run
  a process. In some conditions, it may be more convenient
  to use the <code>kit.exec</code>.
  It will automatically add <code>node_modules/.bin</code> to the <code>PATH</code>
  environment variable.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>cmd</code> { <em>String</em> }</p>
<p>  Path or name of an executable program.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>args</code> { <em>Array</em> }</p>
<p>  CLI arguments. If any of the item is an object,
  it will be converted to string by <code>JSON.stringify</code>.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Process options.
  Same with the Node.js official documentation.
  Except that it will inherit the parent&#39;s stdio.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  The <code>promise.process</code> is the spawned child
  process object.
  <strong>Resolves</strong> when the process&#39;s stdio is drained and the exit
  code is either <code>0</code> or <code>130</code>. The resolve value
  is like:</p>
<pre><code class="lang-coffee">  {
      code: 0
      signal: null
  }
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.spawn &#39;git&#39;, [&#39;commit&#39;, &#39;-m&#39;, &#39;42 is the answer to everything&#39;]
  .then ({code}) -&gt; kit.log code
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-sse-lib-kit-coffee-source-l1798-"><strong><a href="lib/kit.coffee?source#L1798">sse</a></strong></h2>
<p>  The <code>sse</code> module.
  You must <code>kit.require &#39;sse&#39;</code> before using it.
  For more information goto the <code>sse</code> section.</p>
</li>
<li><h2 id="-task-name-opts-fn-lib-kit-coffee-source-l1859-"><strong><a href="lib/kit.coffee?source#L1859">task(name, opts, fn)</a></strong></h2>
<p>  Sequencing and executing tasks and dependencies concurrently.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>name</code> { <em>String</em> }</p>
<p>  The task name.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Optional. Defaults:</p>
<pre><code class="lang-coffee">  {
      deps: String | Array
      description: String
      logStart: -&gt;
      logEnd: -&gt;

      # Whether to run dependency in a row.
      isSequential: false
  }
</code></pre>
</li>
<li><p><strong><u>param</u></strong>: <code>fn</code> { <em>Function</em> }</p>
<p>  <code>(val) -&gt; Promise | Any</code> The task function.
  If it is a async task, it should return a promise.
  It will get its dependency tasks&#39; resolved values.</p>
</li>
<li><p><strong><u>property</u></strong>: <code>run</code> { <em>Function</em> }</p>
<p>  Use it to start tasks. Each task will only run once.
  <code>(names = &#39;default&#39;, opts) -&gt;</code>. The <code>names</code> can be a string or array.
  The default opts:</p>
<pre><code class="lang-coffee">  {
      isSequential: false

      # Will be passed as the first task&#39;s argument.
      init: undefined

      # To stop the run currently in process. Set the `$stop`
      # reference to true. It will reject a &quot;runStopped&quot; error.
      warp: { $stop: false }
  }
</code></pre>
</li>
<li><p><strong><u>property</u></strong>: <code>list</code> { <em>Object</em> }</p>
<p>  The defined task functions.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  Resolve with the last task&#39;s resolved value.
  When <code>isSequential == true</code>, it resolves a value, else it resolves
  an array.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.task &#39;default&#39;, { deps: &#39;build&#39; }, -&gt;
      kit.log &#39;run defaults...&#39;

  kit.task &#39;build&#39;, { deps: [&#39;clean&#39;] }, (isFull) -&gt;
      if isFull
          &#39;do something&#39;
      else
          &#39;do something else&#39;

  kit.task &#39;clean&#39;, (opts) -&gt;
      if opts.isForce
          kit.remove &#39;dist/**&#39;, { isForce: true }
      else
          kit.remove &#39;dist/**&#39;

  kit.task.run()
  .then -&gt;
      kit.log &#39;All Done!&#39;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-url-lib-kit-coffee-source-l1931-"><strong><a href="lib/kit.coffee?source#L1931">url</a></strong></h2>
<p>  The <code>url</code> module of <a href="iojs.org">io.js</a>.
  You must <code>kit.require &#39;url&#39;</code> before using it.</p>
</li>
<li><h2 id="-warp-from-opts-lib-kit-coffee-source-l2046-"><strong><a href="lib/kit.coffee?source#L2046">warp(from, opts)</a></strong></h2>
<p>  Works much like <code>gulp.src</code>, but with Promise instead.
  The warp control and error handling is more pleasant.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>from</code> { <em>String</em> }</p>
<p>  Glob pattern string.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  It extends the options of <code>nofs.glob</code>, but
  with some extra proptereis. Defaults:</p>
<pre><code class="lang-coffee">  {
      # The base directory of the pattern.
      baseDir: String
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Object</em> }</p>
<p>  The returned warp object has these members:</p>
<pre><code class="lang-coffee">  {
      # The drive can also be a promise that will resolve a drive.
      load: (drive) -&gt; fileInfo | null

      run: (path) -&gt; Promise
  }
</code></pre>
<p>  Each piped drive will recieve a
  object that extends <code>nofs</code>&#39;s fileInfo object:</p>
<pre><code class="lang-coffee">  {
      # Set the contents and return self.
      set: (String | Buffer) -&gt; fileInfo

      # The src file path.
      path: String

      # The dest root path.
      to: String

      baseDir: String

      # The destination path.
      # Alter it if you want to change the output file&#39;s location.
      # You can set it to string, warp will auto-convert it to object.
      # It&#39;s &quot;valueOf&quot; will return &quot;kit.path.join dir, name + ext&quot;.
      dest: { root, dir, base, ext, name }

      # The file content.
      contents: String | Buffer

      isDir: Boolean

      stats: fs.Stats

      # Alter it to control the left drives dynamically.
      drives: [Function]

      # All the globbed files.
      list: Array

      driveList: Array

      # The opts you passed to &quot;kit.warp&quot;, it will be extended.
      opts: Object
  }
</code></pre>
<p>  Each drive can have a <code>onEnd: (fileInfo) -&gt; Any | Promise</code> function,
  which will be called after a file&#39;s whole warp is ended.</p>
<p>  The drive can have a <code>isReader</code> property, which will make the drive
  override the default file reader.</p>
<p>  The drive can have a <code>isWriter</code> property, which will make the drive
  override the default file writer.</p>
<p>  If a drive overrides another, it can call <code>fileInfo.super()</code> to use it again.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  # Define a simple workflow.
  kit.warp &#39;src/**/*.js&#39;
  .load (fileInfo) -&gt;
      fileInfo.set &#39;/* Lisence Info */&#39; + fileInfo.contents
  .load jslint()
  .load minify()
  .run &#39;build/minified&#39;

  # Override warp&#39;s file reader with a custom one.
  myReader = kit._.extend (fileInfo) -&gt;
      # Note that we can also use &quot;@path&quot;,
      # its the same with &quot;fileInfo.path&quot; here.
      kit.readFile @path, &#39;hex&#39;
      .then @set
  , {
      # This will tell warp you want use your own reader.
      isReader: true
  }

  # Override writer.
  myWriter = kit._.extend (fileInfo) -&gt;
      return if @dest == &#39;a.js&#39;

      # Call the overrided writer.
      @super()
  , isWriter: true, onEnd: -&gt; @super()
      kit.log @list

  kit.warp &#39;src/**/*.js&#39;
  .load myWriter
  .run &#39;dist&#39;

  # Use nokit&#39;s built-in warp drives.
  drives = kit.require &#39;drives&#39;
  kit.warp src/**/*.coffee&#39;
  .load drives.coffee()
  .run &#39;dist&#39;
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-which-name-lib-kit-coffee-source-l2119-"><strong><a href="lib/kit.coffee?source#L2119">which(name)</a></strong></h2>
<p>  Same as the unix <code>which</code> command.
  You must <code>kit.require &#39;which&#39;</code> before using it.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>name</code> { <em>String</em> }</p>
<p>  The command.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-whichsync-lib-kit-coffee-source-l2126-"><strong><a href="lib/kit.coffee?source#L2126">whichSync</a></strong></h2>
<p>  Sync version of <code>which</code>.
  You must <code>kit.require &#39;whichSync&#39;</code> before using it.</p>
<ul>
<li><strong><u>type</u></strong>: { <em>Function</em> }</li>
</ul>
</li>
<li><h2 id="-xinspect-obj-opts-lib-kit-coffee-source-l2137-"><strong><a href="lib/kit.coffee?source#L2137">xinspect(obj, opts)</a></strong></h2>
<p>  For debugging. Dump a colorful object.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>obj</code> { <em>Object</em> }</p>
<p>  Your target object.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Options. Default:</p>
<pre><code class="lang-coffee">  { colors: true, depth: 7 }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>String</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-xopen-cmds-opts-lib-kit-coffee-source-l2160-"><strong><a href="lib/kit.coffee?source#L2160">xopen(cmds, opts)</a></strong></h2>
<p>  Open a thing that your system can recognize.
  Now only support Windows, OSX or system that installed &#39;xdg-open&#39;.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>cmds</code> { <em>String | Array</em> }</p>
<p>  The thing you want to open.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  The options of the node native
  <code>child_process.exec</code>.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
<p>  When the child process exists.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  # Open a webpage with the default browser.
  kit.open &#39;http://ysmood.org&#39;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="drives">Drives</h1>
<h2 id="quick-start">Quick Start</h2>
<p>Here it will automatically lint, compile, compress and cache files by their extensions. You can goto Drives section to see what extensions are supported,
or write your own.</p>
<pre><code class="lang-coffee">kit = require &#39;nokit&#39;
drives = kit.require &#39;drives&#39;

kit.warp &#39;src/**/*.@(jade|less|coffee|ls)&#39;
    # # To disable cache.
    # .load drives.reader isCache: false
    .load drives.auto &#39;lint&#39;
    .load drives.auto &#39;compile&#39;, &#39;.coffee&#39;: { bare: false }
    .load drives.auto &#39;compress&#39;
    .load concat &#39;main.js&#39;
.run &#39;dist/path&#39;
</code></pre>
<h3 id="write-your-own-drives">Write your own drives</h3>
<p>Nokit has already provided some handy example drives, you
can check them in the Drives section. It&#39;s fairly easy to
write your own.</p>
<pre><code class="lang-coffee">kit = require &#39;nokit&#39;
coffee = require &#39;coffee-script&#39;

# A drive for coffee, a simple curried function.
compiler = (opts) -&gt; -&gt;
    # Change extension from &#39;.coffee&#39; to &#39;.js&#39;.
    @dest.ext = &#39;.js&#39;
    @set coffee.compile(@contents, opts)

# A drive to prepend lisence to each file.
# Here &quot;fileInfo.set&quot; is the same with the &quot;@set&quot;.
lisencer = (lisence) -&gt; (fileInfo) -&gt;
    @set lisence + &#39;\n&#39; + @contents

# A drive to concat all files. It will override the default writer.
concat = (outputFile) -&gt;
    all = &#39;&#39;

    # Object.assign
    kit._.assign -&gt;
        all += @contents
    , isWriter: true, onEnd: -&gt;
        # This will enable the auto-cache.
        @deps = kit._.pluck @list, &#39;path&#39;

        @dest = @to + &#39;/&#39; + outputFile
        @set all

        # Call the overrided writer.
        # Call two times and create two output files.
        @super().then =&gt;
            @dest = @dest + &#39;.info&#39;
            @set = &#39;/* info */\n&#39; + all
            @super()

kit.warp &#39;src/**/*.coffee&#39;
    .load compiler bare: true
    .load lisencer &#39;/* MIT lisence */&#39;
    .load concat &#39;bundle.js&#39;
.run &#39;dist&#39;
.then -&gt;
    kit.log &#39;Build Done&#39;
</code></pre>
<ul>
<li><h2 id="-overview-lib-drives-coffee-source-l10-"><strong><a href="lib/drives.coffee?source#L10">Overview</a></strong></h2>
<p>  The built-in plguins for warp. It&#39;s more like examples
  to show how to use nokit efficiently.</p>
</li>
<li><h2 id="-cleancss-opts-lib-drives-coffee-source-l19-"><strong><a href="lib/drives.coffee?source#L19">cleanCss(opts)</a></strong></h2>
<p>  clean-css</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-coffee-opts-lib-drives-coffee-source-l33-"><strong><a href="lib/drives.coffee?source#L33">coffee(opts)</a></strong></h2>
<p>  coffee-script compiler</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Default is <code>{ bare: true }</code>.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-coffeelint-opts-lib-drives-coffee-source-l68-"><strong><a href="lib/drives.coffee?source#L68">coffeelint(opts)</a></strong></h2>
<p>  coffeelint processor</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  It extends the default config
  of coffeelint, properties:</p>
<pre><code class="lang-coffee">  {
      colorize: true
      reporter: &#39;default&#39;

      # The json of the &quot;coffeelint.json&quot;.
      # If it&#39;s null, coffeelint will try to find
      # &quot;coffeelint.json&quot; as its content.
      config: null | JSON | JsonFilePath
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-comment2md-path-opts-lib-drives-coffee-source-l123-"><strong><a href="lib/drives.coffee?source#L123">comment2md(path, opts)</a></strong></h2>
<p>  Parse commment from a js, coffee, or livescript file,
  and output a markdown string.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>path</code> { <em>String</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      # Output doc path.
      out: &#39;readme.md&#39;

      # jst template path.
      tpl: &#39;readme.jst.md&#39;

      # Init doc info.
      doc: {}

      # Header size.
      h: 3

      parseComment: -&gt; ...
      formatComment: -&gt; ...
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<p>  The nofile of nokit shows how to use it.</p>
</li>
</ul>
</li>
<li><h2 id="-auto-action-opts-lib-drives-coffee-source-l178-"><strong><a href="lib/drives.coffee?source#L178">auto(action, opts)</a></strong></h2>
<p>  Auto-compiler file by extension. It will search through
  <code>kit.drives</code>, and find proper drive to run the task.
  You can extend <code>kit.drives</code> to let it support more.
  For example:</p>
<pre><code class="lang-coffee">  kit.drives.myCompiler = kit._.extend -&gt;
      # your compile logic
  , compiler: [&#39;.jsx&#39;]
</code></pre>
<ul>
<li><p><strong><u>param</u></strong>: <code>action</code> { <em>String</em> }</p>
<p>  By default, it can be
  &#39;compile&#39; or &#39;compress&#39; or &#39;lint&#39;</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<pre><code class="lang-coffee">  {
      # If no compiler match.
      onNotFound: (fileInfo) -&gt;
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-changedir-dir-filter-lib-drives-coffee-source-l214-"><strong><a href="lib/drives.coffee?source#L214">changeDir(dir, filter)</a></strong></h2>
<p>  Change dest path with a filter.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>dir</code> { <em>String</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>filter</code> { <em>Function</em> }</p>
<p>  <code>(fileInfo, dir) -&gt; Boolean</code></p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-concat-name-dir-lib-drives-coffee-source-l229-"><strong><a href="lib/drives.coffee?source#L229">concat(name, dir)</a></strong></h2>
<p>  a batch file concat helper</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>name</code> { <em>String</em> }</p>
<p>  The output file path.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>dir</code> { <em>String</em> }</p>
<p>  Optional. Override the dest of warp&#39;s.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-hashsuffix-hashmappath-lib-drives-coffee-source-l249-"><strong><a href="lib/drives.coffee?source#L249">hashSuffix(hashMapPath)</a></strong></h2>
<p>  Suffix file name with the hash value of file content.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>hashMapPath</code> { <em>String</em> }</p>
<p>  The output file name hash map.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-jshint-opts-lib-drives-coffee-source-l274-"><strong><a href="lib/drives.coffee?source#L274">jshint(opts)</a></strong></h2>
<p>  Lint js via <code>jshint</code>.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Properties:</p>
<pre><code class="lang-coffee">  {
      global: null
      config: null | JSON | JsonFilePath
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-less-lib-drives-coffee-source-l307-"><strong><a href="lib/drives.coffee?source#L307">less()</a></strong></h2>
<p>  Compile less.</p>
<ul>
<li><p><strong><u>param</u></strong>: { <em>Object</em> }</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-livescript-opts-lib-drives-coffee-source-l334-"><strong><a href="lib/drives.coffee?source#L334">livescript(opts)</a></strong></h2>
<p>  LiveScript compiler.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Default is <code>{ bare: true }</code>.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-mocha-opts-lib-drives-coffee-source-l363-"><strong><a href="lib/drives.coffee?source#L363">mocha(opts)</a></strong></h2>
<p>  mocha test</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<pre><code>  {
      timeout: 5000
  }
</code></pre></li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-reader-opts-lib-drives-coffee-source-l393-"><strong><a href="lib/drives.coffee?source#L393">reader(opts)</a></strong></h2>
<p>  read file and set <code>contents</code></p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      isCache: true
      encoding: &#39;utf8&#39;
      cacheDir: &#39;.nokit/warp&#39;
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-stylus-opts-lib-drives-coffee-source-l462-"><strong><a href="lib/drives.coffee?source#L462">stylus(opts)</a></strong></h2>
<p>  Compile stylus.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  It will use <code>stylus.set</code> to
  iterate <code>opts</code> and set the key-value, is the value is
  not a function.</p>
<pre><code class="lang-coffee">  {
      config: (styl) -&gt;
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit.drives.stylus {
      compress: true
      config: (styl) -&gt;
          styl.define &#39;jack&#39;, &#39;a persion&#39;
  }
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-uglifyjs-opts-lib-drives-coffee-source-l502-"><strong><a href="lib/drives.coffee?source#L502">uglifyjs(opts)</a></strong></h2>
<p>  uglify-js processor</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      output:
          comments: (node, comment) -&gt;
              text = comment.value
              type = comment.type
              if type == &quot;comment2&quot;
                  return /@preserve|@license|@cc_on/i.test text
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-writer-lib-drives-coffee-source-l527-"><strong><a href="lib/drives.coffee?source#L527">writer()</a></strong></h2>
<p>  Output file by <code>contents</code> and <code>dest</code>.
  If the &#39;ext&#39; or &#39;name&#39; is not null,
  the &#39;base&#39; will be override by the &#39;ext&#39; and &#39;name&#39;.</p>
<ul>
<li><strong><u>return</u></strong>: { <em>Function</em> }</li>
</ul>
</li>
</ul>
<h1 id="ken">Ken</h1>
<ul>
<li><h2 id="-ken-opts-lib-ken-coffee-source-l50-"><strong><a href="lib/ken.coffee?source#L50">ken(opts)</a></strong></h2>
<p>  A simple promise based test module.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffeescript">  {
      isBail: true
      logPass: (msg) -&gt;
          console.log cs.green(&#39;o&#39;), msg
      logFail: (err) -&gt;
          console.error cs.red(&#39;x&#39;), err
      logFinal: (passed, failed) -&gt;
          console.log &quot;&quot;&quot;
          #{cs.grey &#39;----------------&#39;}
          pass  #{cs.green passed}
          fail  #{cs.red failed}
          &quot;&quot;&quot;
      onEnd: (passed, failed) -&gt;
          if failed
              process.exit 1
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Promise</em> }</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffeescript">  ken = kit.require &#39;ken&#39;
  test = ken()

  # Async tests
  test.async [
      test &#39;basic 1&#39;, -&gt;
          ken.eq &#39;ok&#39;, &#39;ok&#39;
      test &#39;basic 2&#39;, -&gt;
          ken.deepEq { a: 1, b: 2 }, { a: 1, b: 2 }

      # Sync tests
      kit.flow [
          test &#39;basic 3&#39;, -&gt;
              ken.eq &#39;ok&#39;, &#39;ok&#39;
          test &#39;basic 4&#39;, -&gt;
              ken.eq &#39;ok&#39;, &#39;ok&#39;
      ]
  ]
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="proxy">Proxy</h1>
<ul>
<li><h2 id="-overview-lib-proxy-coffee-source-l6-"><strong><a href="lib/proxy.coffee?source#L6">Overview</a></strong></h2>
<p>  For test, page injection development.
  A cross-platform programmable Fiddler alternative.
  You can even replace express.js with it&#39;s <code>flow</code> function.</p>
</li>
<li><h2 id="-body-lib-proxy-coffee-source-l20-"><strong><a href="lib/proxy.coffee?source#L20">body()</a></strong></h2>
<p>  A simple request body middleware.</p>
<ul>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
<p>  <code>(ctx) -&gt; Promise</code></p>
</li>
</ul>
</li>
<li><h2 id="-connect-req-sock-head-host-port-err-lib-proxy-coffee-source-l53-"><strong><a href="lib/proxy.coffee?source#L53">connect(req, sock, head, host, port, err)</a></strong></h2>
<p>  Http CONNECT method tunneling proxy helper.
  Most times used with https proxing.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>req</code> { <em>http.IncomingMessage</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>sock</code> { <em>net.Socket</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>head</code> { <em>Buffer</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>host</code> { <em>String</em> }</p>
<p>  The host force to. It&#39;s optional.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>port</code> { <em>Int</em> }</p>
<p>  The port force to. It&#39;s optional.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>err</code> { <em>Function</em> }</p>
<p>  Custom error handler.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit = require &#39;nokit&#39;
  kit.require &#39;proxy&#39;
  http = require &#39;http&#39;

  server = http.createServer()

  # Directly connect to the original site.
  server.on &#39;connect&#39;, kit.proxy.connect

  server.listen 8123
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-flow-middlewares-opts-lib-proxy-coffee-source-l191-"><strong><a href="lib/proxy.coffee?source#L191">flow(middlewares, opts)</a></strong></h2>
<p>  A promise based middlewares proxy.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>middlewares</code> { <em>Array</em> }</p>
<p>  Each item is a function <code>(ctx) -&gt; Promise</code>,
  or a middleware object:</p>
<pre><code class="lang-coffee">  {
      url: String | Regex | Function
      method: String | Regex | Function
      handler: ({ body, req, res, next, url, method, headers }) -&gt; Promise | Any

      # When this, it will be assigned to ctx.body
      handler: String | Object | Promise | Stream
  }
</code></pre>
<p>  <h4>selector</h4>
  The <code>url</code>, <code>method</code> and <code>headers</code> are act as selectors. If current
  request matches the selector, the <code>handler</code> will be called with the
  captured result. If the selector is a function, it should return a
  <code>non-undefined, non-null</code> value when matches, it will be assigned to the <code>ctx</code>.
  When the <code>url</code> is a string, if <code>req.url</code> starts with the <code>url</code>, the rest
  of the string will be captured.
  <h4>handler</h4>
  If the handler has async operation inside, it should return a promise,
  the promise can reject an error with a http <code>statusCode</code> property.
  <h4>body</h4>
  The <code>body</code> can be a <code>String</code>, <code>Buffer</code>, <code>Stream</code>, <code>Object</code> or a <code>Promise</code>
  contains previous types.
  <h4>next</h4>
  <code>-&gt; Promise</code> It returns a promise which settles after all the next middlewares
  are setttled.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>opts</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      # If it returns true, the http will end with 304.
      etag: (ctx, data, isStr) -&gt; Boolean
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
<p>  <code>(req, res) -&gt; Promise | Any</code> or <code>(ctx) -&gt; Promise</code>.
  The http request listener or middleware.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  proxy = kit.require &#39;proxy&#39;
  http = require &#39;http&#39;

  middlewares = [
      (ctx) -&gt;
          start = new Date
          ctx.next().then -&gt;
              console.log ctx.req.url, new Date - start
          , (err) -&gt;
              console.error err
      {
          url: //items/(\d+)$/
          handler: (ctx) -&gt;
              ctx.body = kit.sleep(300).then -&gt; &#39;Hello World&#39;
      }
      {
          url: &#39;/api&#39;
          handler: { fake: &#39;api&#39; }
      }
  ]

  http.createServer(proxy.flow middlewares).listen 8123
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<p>  Express like path to named capture.</p>
<pre><code class="lang-coffee">  proxy = kit.require &#39;proxy&#39;
  http = require &#39;http&#39;

  middlewares = [
      {
          url: proxy.match &#39;/items/:id&#39;
          handler: (ctx) -&gt;
              ctx.body = ctx.url.id
      }
  ]

  http.createServer(proxy.flow middlewares).listen 8123
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<p>  Use with normal thrid middlewares. This example will map
  <code>http://127.0.0.1:8123/st</code> to the <code>static</code> folder.</p>
<pre><code class="lang-coffee">  proxy = kit.require &#39;proxy&#39;
  http = require &#39;http&#39;
  send = require &#39;send&#39;
  bodyParser = require(&#39;body-parser&#39;)

  middlewares = [
      # Express middleware
      proxy.midToFlow bodyParser.json()

      {
          url: &#39;/st&#39;
          handler: (ctx) -&gt;
              ctx.body = send(ctx.req, ctx.url, { root: &#39;static&#39; })
      }

      # sub-route
      {
          url: &#39;/sub&#39;
          handler: proxy.flow([{
              url: &#39;/home&#39;
              handler: (ctx) -&gt;
                  ctx.body = &#39;hello world&#39;
          }])
      }
  ]

  http.createServer(proxy.flow middlewares).listen 8123
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-match-pattern-opts-lib-proxy-coffee-source-l382-"><strong><a href="lib/proxy.coffee?source#L382">match(pattern, opts)</a></strong></h2>
<p>  Generate an express like unix path selector. See the example of <code>proxy.flow</code>.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>pattern</code> { <em>String</em> }</p>
</li>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Same as the <a href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a>&#39;s
  options.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
<p>  <code>(String) -&gt; Object</code>.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  proxy = kit.require &#39;proxy&#39;
  match = proxy.match &#39;/items/:id&#39;
  kit.log match &#39;/items/10&#39; # output =&gt; { id: &#39;10&#39; }
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-midtoflow-h-lib-proxy-coffee-source-l401-"><strong><a href="lib/proxy.coffee?source#L401">midToFlow(h)</a></strong></h2>
<p>  Convert a Express-like middleware to <code>proxy.flow</code> middleware.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>h</code> { <em>Function</em> }</p>
<p>  <code>(req, res, next) -&gt;</code></p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
<p>  <code>(ctx) -&gt; Promise</code></p>
</li>
</ul>
</li>
<li><h2 id="-serverhelper-opts-lib-proxy-coffee-source-l447-"><strong><a href="lib/proxy.coffee?source#L447">serverHelper(opts)</a></strong></h2>
<p>  Create a http request handler middleware.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Same as the sse.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
<p>  <code>(req, res, next) -&gt;</code>.
  It has some extra properties:</p>
<pre><code class="lang-coffee">  {
      sse: kit.sse
      watch: (filePath, reqUrl) -&gt;
  }
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<p>  Visit &#39;<a href="http://127.0.0.1:80123">http://127.0.0.1:80123</a>&#39;, every 3 sec, the page will be reloaded.
  If the <code>./static/default.css</code> is modified, the page will also be reloaded.</p>
<pre><code class="lang-coffee">  kit = require &#39;nokit&#39;
  http = require &#39;http&#39;
  proxy = kit.require &#39;proxy&#39;
  handler = kit.browserHelper()

  http.createServer proxy.flow [handler]
  .listen 8123, -&gt;
      kit.log &#39;listen &#39; + 8123

      handler.watch &#39;./static/default.css&#39;, &#39;/st/default.css&#39;

      setInterval -&gt;
          handler.sse.emit &#39;fileModified&#39;, &#39;changed-file-path.js&#39;
      , 3000
</code></pre>
<p>  You can also use the <code>nokit.log</code> on the browser to log to the remote server.</p>
<pre><code class="lang-coffee">  nokit.log { any: &#39;thing&#39; }
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-static-opts-lib-proxy-coffee-source-l513-"><strong><a href="lib/proxy.coffee?source#L513">static(opts)</a></strong></h2>
<p>  Create a static file middleware for <code>proxy.flow</code>.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>String | Object</em> }</p>
<p>  Same as the <a href="https://github.com/pillarjs/send">send</a>&#39;s.
  It has an extra option <code>{ onFile: (path, stats, ctx) -&gt; }</code>.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
<p>  The middleware handler of <code>porxy.flow</code>.</p>
<pre><code class="lang-coffee">  proxy = kit.require &#39;proxy&#39;
  http = require &#39;http&#39;

  middlewares = [{
      url: &#39;/st&#39;
      handler: proxy.static(&#39;static&#39;)
  }]

  http.createServer(proxy.flow middlewares).listen 8123
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-url-opts-lib-proxy-coffee-source-l609-"><strong><a href="lib/proxy.coffee?source#L609">url(opts)</a></strong></h2>
<p>  Use it to proxy one url to another.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object | String</em> }</p>
<p>  Other options, if it is a string, it will
  be converted to <code>{ url: opts }</code>. Default:</p>
<pre><code class="lang-coffee">  {
      # The target url forced to. Optional.
      # Such as proxy &#39;http://test.com/a&#39; to &#39;http://test.com/b&#39;,
      # proxy &#39;http://test.com/a&#39; to &#39;http://other.com/a&#39;,
      # proxy &#39;http://test.com&#39; to &#39;other.com&#39;.
      # It can also be an url object. Such as
      # `{ protocol: &#39;http:&#39;, host: &#39;test.com:8123&#39;, pathname: &#39;/a/b&#39;, query: &#39;s=1&#39; }`.
      url: null

      # Limit the bandwidth byte per second.
      bps: Integer

      # if the bps is the global bps.
      globalBps: false

      agent: customHttpAgent

      # Force the header&#39;s host same as the url&#39;s.
      isForceHeaderHost: true

      # You can hack the headers before the proxy send it.
      handleReqHeaders: (headers, req) -&gt; headers
      handleResHeaders: (headers, req, proxyRes) -&gt; headers

      # Same option as the `kit.request`&#39;s `handleResPipe`.
      handleResPipe: (res, stream) -&gt; stream

      # Manipulate the response body content of the response here,
      # such as inject script into it. Its return type is same as the `ctx.body`.
      handleResBody: (body, req, proxyRes) -&gt; body

      # It will log some basic error info.
      error: (e, req) -&gt;
  }
</code></pre>
</li>
<li><p><strong><u>return</u></strong>: { <em>Function</em> }</p>
<p>  <code>(req, res) -&gt; Promise</code> A middleware.</p>
</li>
<li><p><strong><u>example</u></strong>:</p>
<pre><code class="lang-coffee">  kit = require &#39;nokit&#39;
  proxy = kit.require &#39;proxy&#39;
  http = require &#39;http&#39;

  http.createServer(proxy.flow [{
          url: &#39;/a&#39;
          handler: proxy.url() # Transparent proxy
      }, {
          url: &#39;/b&#39;
          handler proxy.url { url: &#39;a.com&#39; } # Porxy to `a.com`
      }, {
          url: &#39;/c&#39;
          handler proxy.url { url: &#39;c.com/s.js&#39; } # Porxy to a file
      }, {
          url: //$/ # match path that ends with &#39;/&#39;
          method: &#39;GET&#39;
          handler proxy.url {
              url: &#39;d.com&#39;
              # Inject script to html page.
              handleResBody: (body, req, res) -&gt;
                  if res.headers[&#39;content-type&#39;].indexOf(&#39;text/html&#39;) &gt; -1
                      body + &#39;&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;&#39;
                  else
                      body
          }
      }]
  ).listen 8123
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="sse">SSE</h1>
<ul>
<li><h2 id="-sse-opts-lib-sse-coffee-source-l37-"><strong><a href="lib/sse.coffee?source#L37">sse(opts)</a></strong></h2>
<p>  A Server-Sent Event Manager.
  For more info see <a href="https://developer.mozilla.org/en-US/docs/Server-sentEvents/UsingServer-sentEvents">Using server-sent events</a>.
  It is used to implement the live-reload of web assets.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>opts</code> { <em>Object</em> }</p>
<p>  Defaults:</p>
<pre><code class="lang-coffee">  {
      # The reconnection time to use when attempting to send the event, unit is ms.
      retry: 1000
  }
</code></pre>
</li>
<li><p><strong><u>example</u></strong>:</p>
<p>  Your server side code may look like this:</p>
<pre><code class="lang-coffee">  http = require &#39;http&#39;
  kit = require &#39;nokit&#39;
  sse = kit.require &#39;sse&#39;
  sseHandler = sse()
  http.createServer (req, res) -&gt;
      if req.url == &#39;/sse&#39;
       sseHandler req, res
   else
       res.end()
  .listen 8080, -&gt;
      setTimeout -&gt;
          sseHandler.emit &#39;test&#39;, { test: &#39;ok&#39; }
</code></pre>
<p>  You browser code should be something like this:</p>
<pre><code class="lang-coffee">  es = new EventSource(&#39;/sse&#39;)
  es.addEventListener(&#39;test&#39;, (e) -&gt;
      msg = JSON.parse(e.data)
   console.log(msg) # =&gt; { test: &#39;ok&#39; }
</code></pre>
</li>
</ul>
</li>
<li><h2 id="-self-req-res-lib-sse-coffee-source-l44-"><strong><a href="lib/sse.coffee?source#L44">self(req, res)</a></strong></h2>
<p>  The sse middleware for http handler.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>req</code> { <em>http.IncomingMessage</em> }</p>
<p>  Also supports Express.js.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>res</code> { <em>http.ServerResponse</em> }</p>
<p>  Also supports Express.js.</p>
</li>
</ul>
</li>
<li><h2 id="-sessions-lib-sse-coffee-source-l54-"><strong><a href="lib/sse.coffee?source#L54">sessions</a></strong></h2>
<p>  The sessions of connected clients.</p>
<ul>
<li><strong><u>type</u></strong>: { <em>Array</em> }</li>
</ul>
</li>
<li><h2 id="-emit-event-msg-lib-sse-coffee-source-l63-"><strong><a href="lib/sse.coffee?source#L63">emit(event, msg, )</a></strong></h2>
<p>  Broadcast a event to all clients.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>event</code> { <em>String</em> }</p>
<p>  The event name.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>msg</code> { <em>Object | String</em> }</p>
<p>  The data you want to emit to session.</p>
</li>
<li><p><strong><u>param</u></strong>: { <em>String</em> }</p>
<p>  [path] The namespace of target sessions. If not set,
  broadcast to all clients.</p>
</li>
</ul>
</li>
<li><h2 id="-create-req-res-lib-sse-coffee-source-l76-"><strong><a href="lib/sse.coffee?source#L76">create(req, res)</a></strong></h2>
<p>  Create a sse session.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>req</code> { <em>http.IncomingMessage</em> }</p>
<p>  Also supports Express.js.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>res</code> { <em>http.ServerResponse</em> }</p>
<p>  Also supports Express.js.</p>
</li>
<li><p><strong><u>return</u></strong>: { <em>SSESession</em> }</p>
</li>
</ul>
</li>
<li><h2 id="-session-lib-sse-coffee-source-l86-"><strong><a href="lib/sse.coffee?source#L86">session</a></strong></h2>
<p>  A session object is something like:</p>
<pre><code class="lang-coffee">  {
      req  # The http req object.
   res  # The http res object.
  }
</code></pre>
</li>
<li><h2 id="-session-emit-event-msg-lib-sse-coffee-source-l100-"><strong><a href="lib/sse.coffee?source#L100">session.emit(event, msg)</a></strong></h2>
<p>  Emit message to client.</p>
<ul>
<li><p><strong><u>param</u></strong>: <code>event</code> { <em>String</em> }</p>
<p>  The event name.</p>
</li>
<li><p><strong><u>param</u></strong>: <code>msg</code> { <em>Object | String</em> }</p>
<p>  The message to send to the client.</p>
</li>
</ul>
</li>
</ul>
<h1 id="contribution">Contribution</h1>
<h2 id="unit-test">Unit Test</h2>
<p><code>npm test</code>
or <code>npm run no -- test</code></p>
<h2 id="others">Others</h2>
<p>Run <code>npm run no -- -h</code> for all command you can use.
Such as run <code>npm run no -- build</code> to build this project.</p>
<h2 id="docs">Docs</h2>
<p>Edit the templete of the readme at <code>doc/readme.jst.md</code>.</p>
<h1 id="lisence">Lisence</h1>
<p>MIT</p>

	</div>
</div>

<div id="toc">
	<h1>Table of Contents</h1>
	<div class="content"></div>
</div>

<script type="text/javascript" src="assets/markdown/sh/shCore.js?noboneAssets"></script>
<script type="text/javascript" src="assets/markdown/sh/brushes.js?noboneAssets"></script>
<script type="text/javascript" src="assets/markdown/main.js?noboneAssets"></script>

</body>
</html>
