# Overview

A light weight set of handy functions.

Reduce the gap between working on different systems. Such as watch directory changes on a network file system, operate `spawn` on Windows and Linux, handle async IO api with promise, etc.

Rather than help you decide what to do, it is designed to create possibilities. Most times I use it as the core a build system, even this document is generated by nokit itself.

It's one of the core lib of [nobone](https://github.com/ysmood/nobone).

[![NPM version](https://badge.fury.io/js/nokit.svg)](http://badge.fury.io/js/nokit) [![Build Status](https://travis-ci.org/ysmood/nokit.svg)](https://travis-ci.org/ysmood/nokit) [![Build status](https://ci.appveyor.com/api/projects/status/3pwhk4ua9c3ojm0q?svg=true)](https://ci.appveyor.com/project/ysmood/nokit) [![Deps Up to Date](https://david-dm.org/ysmood/nokit.svg?style=flat)](https://david-dm.org/ysmood/nokit)

## Features

- Full promise sollution.
- All functions are highly lazy designed, minimum boot time.
- Test on Node 0.8 - 0.11 on Mac, Linux and Windows.
- Light weight and self-reference.

# Installation

As a lib dependency, install it locally: `npm i nokit`.

Nokit has provided a cli tool like GNU Make. If you install it globally like this:

`npm -g i nokit commander`

, then have fun with your `nofile`, it can be js, coffee or livescript. For more information goto the `CLI` section.

# Quick Start

## vs Gulp

Here it will automatically lint, compile, compress and cache files by their extensions. You can goto Drives section to see what extensions are supported,
or write your own.

```coffee
kit = require 'nokit'
drives = kit.require 'drives'

kit.warp 'src/**/*.@(coffee|ls)'
    .load drives.auto 'lint'
    .load drives.auto 'compile', '.coffee': { bare: false }
    .load drives.auto 'compress'
    .load concat 'main.js'
.run 'dist/path'

```

### Write your own drives

Nokit has already provided some handy example drives, you
can check them in the Drives section. It's fairly easy to
write your own.

```coffee
kit = require 'nokit'
coffee = require 'coffee-script'

# A drive for coffee, a simple curried function.
compiler = (opts) -> ->
    # Change extension from '.coffee' to '.js'.
    @dest.ext = '.js'
    @set coffee.compile(@contents, opts)

# A drive to prepend lisence to each file.
# Here "fileInfo.set" is the same with the "@set".
lisencer = (lisence) -> (fileInfo) ->
    @set lisence + '\n' + @contents

# A drive to concat all files. It will override the default writer.
concat = (outputFile) ->
    all = ''

    kit._.extend ->
        if @isWarpEnd
            # This will enable the auto-cache.
            @deps = kit._.pluck @list, 'path'

            @dest = @to + '/' + outputFile
            @set all

            # Call the build-in writer.
            kit.drives.writer(@opts).call @, @
        else
            all += @contents
    , isWriter: true

kit.warp 'src/**/*.coffee'
    .load compiler bare: true
    .load lisencer '/* MIT lisence */'
    .load concat 'bundle.js'
.run 'dist'
.then ->
    kit.log 'Build Done'
```

## CLI

If you want nokit support coffee, you should install it like this:

`npm i -g nokit commander coffee-cache coffee-script`

> It's recommended to use coffee-cache, since large build project may
> consume a large portion of your nofile's startup time. Of course, it's
> optional, you may run `npm i -g nokit commander coffee-script` without
> any problem.

Same works with livescript:

`npm i -g nokit commander LiveScript`

> Remarks: for the sake of boot performance, nokit will only load
> `coffee-cache coffee-script/register`
> by default. For livescript or other precompiler, you have to
> set environment varialbe `nokitPreload` to what you want, such as on unix:
> `export nokitPreload='LiveScript coffee-script/register'`. Different module
> names are separated by spaces.

Create a `nofile.coffee` (or `.js`, `.ls`) at your current working directory
or any of its parents directory. The syntax of `nofile` is almost the same as the Cakefile, only the `option`'s first argument is slightly changed.

Assume your file content is:

```coffee
# There are some global variables you can call directly:
# _: lodash
# option: commander.option
# task: kit.task
# warp: kit.warp
# kit: kit
# Promise: kit.Promise

option '-w, --hello [world]', 'Just a test option', ''

# Define a default task, and it depends on the "clean" task.
task 'default', ['clean'], 'This is a comment info', (opts) ->
    kit.log opts.hello

    # "colors" is enabled by default.
    kit.log 'print red words'.red

task 'clean', ->
    kit.remove 'dist'

# To add alias to a task, just use space to separate names.
# Here 'build' and 'b' are the same task.
task 'build b', ->
    warp 'src/**/*.js'
    .load (file) ->
        file.set '/* Nothing */' + file.contents
    .run 'dist'

task 'sequential', ['clean', 'build'], true, ->
    kit.log 'Run clean and build non-concurrently.'
```

Then you can run it in command line: `no`. Just that simple, without task
name, `no` will try to call the `default` task directly.

You can run `no -h` to display help info.

Call `no build` or `no b` to run the `build` task.

For real world example, just see the [nofile](nofile.coffee?source) that nokit is using.

For more doc for the `option` goto [commander.js](https://github.com/tj/commander.js).

# Changelog

Goto [changelog](doc/changelog.md)

# API

<%= doc['lib/kit.coffee'] %>

# Drives

<%= doc['lib/drives.coffee'] %>

# Lisence

MIT