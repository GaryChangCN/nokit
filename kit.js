// Generated by CoffeeScript 1.8.0
var Q, colors, fs, glob, k, kit, kit_extends_fs_q, node_verion, v, _,
  __slice = [].slice;

colors = require('colors');

if (process.env.NODE_ENV === 'production') {
  colors.mode = 'none';
}

_ = require('lodash');

Q = require('q');

fs = require('fs-more');

glob = require('glob');

node_verion = +process.versions.node.match(/\d+\.(\d+)\.\d+/)[1];

Q.longStackSupport = process.env.NODE_ENV === 'development';

kit = {};


/**
 * kit extends all the Q functions of [fs-more][fs-more].
 * [fs-more]: https://github.com/ysmood/fs-more
 * @example
 * ```coffeescript
 * kit.readFile('test.txt').done (str) ->
 * 	console.log str
 *
 * kit.outputFile('a.txt', 'test').done()
 * ```
 */

kit_extends_fs_q = 'Q';

for (k in fs) {
  v = fs[k];
  if (k.slice(-1) === 'Q') {
    kit[k.slice(0, -1)] = fs[k];
  }
}

_.extend(kit, {

  /**
  	 * The lodash lib.
  	 * @type {Object}
   */
  _: _,
  require_cache: {},

  /**
  	 * An throttle version of `Q.all`, it runs all the tasks under
  	 * a concurrent limitation.
  	 * @param  {Int} limit The max task to run at the same time. It's optional.
  	 * Default is Infinity.
  	 * @param  {Array | Function} list
  	 * If the list is an array, it should be a list of functions or promises. And each function will return a promise.
  	 * If the list is a function, it should be a iterator that returns a promise,
  	 * when it returns `undefined`, the iteration ends.
  	 * @param {Boolean} save_resutls Whether to save each promise's result or not.
  	 * @return {Promise} You can get each round's results by using the `promise.progress`.
   */
  async: function(limit, list, save_resutls) {
    var add_task, all_done, defer, from, i, is_iter_done, iter, iter_index, list_len, resutls, running, _i;
    if (save_resutls == null) {
      save_resutls = true;
    }
    from = 0;
    resutls = [];
    iter_index = 0;
    running = 0;
    is_iter_done = false;
    defer = Q.defer();
    if (!_.isNumber(limit)) {
      save_resutls = list;
      list = limit;
      limit = Infinity;
    }
    if (_.isArray(list)) {
      list_len = list.length - 1;
      iter = function(i) {
        if (i > list_len) {
          return;
        }
        if (_.isFunction(list[i])) {
          return list[i](i);
        } else {
          return list[i];
        }
      };
    } else if (_.isFunction(list)) {
      iter = list;
    } else {
      throw new Error('unknown list type: ' + typeof list);
    }
    add_task = function() {
      var p, task;
      task = iter(iter_index++);
      if (is_iter_done || task === void 0) {
        is_iter_done = true;
        if (running === 0) {
          all_done();
        }
        return false;
      }
      if (Q.isPromise(task)) {
        p = task;
      } else {
        p = Q(task);
      }
      running++;
      p.then(function(ret) {
        running--;
        if (save_resutls) {
          resutls.push(ret);
        }
        defer.notify(ret);
        return add_task();
      })["catch"](function(err) {
        running--;
        return defer.reject(err);
      });
      return true;
    };
    all_done = function() {
      if (save_resutls) {
        return defer.resolve(resutls);
      } else {
        return defer.resolve();
      }
    };
    for (i = _i = 0; 0 <= limit ? _i < limit : _i > limit; i = 0 <= limit ? ++_i : --_i) {
      if (!add_task()) {
        break;
      }
    }
    return defer.promise;
  },

  /**
  	 * Creates a function that is the composition of the provided functions.
  	 * Besides it can also accept async function that returns promise.
  	 * It's more powerful than `_.compose`.
  	 * @param  {Function | Array} fns Functions that return promise or any value.
  	 * @return {Function} A composed function that will return a promise.
  	 * @example
  	 * ```coffeescript
  	 * # It helps to decouple sequential pipeline code logic.
  	 *
  	 * create_url = (name) ->
  	 * 	return "http://test.com/" + name
  	 *
  	 * curl = (url) ->
  	 * 	kit.request(url).then ->
  	 * 		kit.log 'get'
  	 *
  	 * save = (str) ->
  	 * 	kit.outputFile('a.txt', str).then ->
  	 * 		kit.log 'saved'
  	 *
  	 * download = kit.compose create_url, curl, save
  	 * # same as "download = kit.compose [create_url, curl, save]"
  	 *
  	 * download()
  	 * ```
   */
  compose: function() {
    var fns;
    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(val) {
      if (_.isArray(fns[0])) {
        fns = fns[0];
      }
      return fns.reduce(function(pre_fn, fn) {
        return pre_fn.then(fn);
      }, Q(val));
    };
  },

  /**
  	 * Daemonize a program.
  	 * @param  {Object} opts Defaults:
  	 * {
  	 * 	bin: 'node'
  	 * 	args: ['app.js']
  	 * 	stdout: 'stdout.log'
  	 * 	stderr: 'stderr.log'
  	 * }
  	 * @return {Porcess} The daemonized process.
   */
  daemonize: function(opts) {
    var err_log, out_log, p;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      bin: 'node',
      args: ['app.js'],
      stdout: 'stdout.log',
      stderr: 'stderr.log'
    });
    out_log = os.openSync(opts.stdout, 'a');
    err_log = os.openSync(opts.stderr, 'a');
    p = kit.spawn(opts.bin, opts.args, {
      detached: true,
      stdio: ['ignore', out_log, err_log]
    }).process;
    p.unref();
    kit.log(("Run as background daemon, PID: " + p.pid).yellow);
    return p;
  },

  /**
  	 * A simple decrypt helper
  	 * @param  {Any} data
  	 * @param  {String | Buffer} password
  	 * @param  {String} algorithm Default is 'aes128'.
  	 * @return {Buffer}
   */
  decrypt: function(data, password, algorithm) {
    var crypto, decipher;
    if (algorithm == null) {
      algorithm = 'aes128';
    }
    crypto = kit.require('crypto');
    decipher = crypto.createDecipher(algorithm, password);
    if (node_verion < 10) {
      if (Buffer.isBuffer(data)) {
        data = data.toString('binary');
      }
      return new Buffer(decipher.update(data, 'binary') + decipher.final(), 'binary');
    } else {
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data);
      }
      return Buffer.concat([decipher.update(data), decipher.final()]);
    }
  },

  /**
  	 * A simple encrypt helper
  	 * @param  {Any} data
  	 * @param  {String | Buffer} password
  	 * @param  {String} algorithm Default is 'aes128'.
  	 * @return {Buffer}
   */
  encrypt: function(data, password, algorithm) {
    var cipher, crypto;
    if (algorithm == null) {
      algorithm = 'aes128';
    }
    crypto = kit.require('crypto');
    cipher = crypto.createCipher(algorithm, password);
    if (node_verion < 10) {
      if (Buffer.isBuffer(data)) {
        data = data.toString('binary');
      }
      return new Buffer(cipher.update(data, 'binary') + cipher.final(), 'binary');
    } else {
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data);
      }
      return Buffer.concat([cipher.update(data), cipher.final()]);
    }
  },

  /**
  	 * A shortcut to set process option with specific mode,
  	 * and keep the current env variables.
  	 * @param  {String} mode 'development', 'production', etc.
  	 * @return {Object} `process.env` object.
   */
  env_mode: function(mode) {
    return {
      env: _.defaults({
        NODE_ENV: mode
      }, process.env)
    };
  },

  /**
  	 * A log error shortcut for `kit.log(msg, 'error', opts)`
  	 * @param  {Any} msg
  	 * @param  {Object} opts
   */
  err: function(msg, opts) {
    if (opts == null) {
      opts = {};
    }
    return kit.log(msg, 'error', opts);
  },

  /**
  	 * See my project [fs-more][fs-more].
  	 * [fs-more]: https://github.com/ysmood/fs-more
   */
  fs: fs,

  /**
  	 * A scaffolding helper to generate template project.
  	 * The `lib/cli.coffee` used it as an example.
  	 * @param  {Object} opts Defaults:
  	 * ```coffeescript
  	 * {
  	 * 	src_dir: null
  	 * 	patterns: '**'
  	 * 	dest_dir: null
  	 * 	data: {}
  	 * 	compile: (str, data, path) ->
  	 * 		compile str
  	 * }
  	 * ```
  	 * @return {Promise}
   */
  generate_bone: function(opts) {

    /*
    			It will treat all the files in the path as an ejs file
     */
    _.defaults(opts, {
      src_dir: null,
      patterns: ['**', '**/.*'],
      dest_dir: null,
      data: {},
      compile: function(str, data, path) {
        var ejs;
        ejs = kit.require('ejs');
        data.filename = path;
        return ejs.render(str, data);
      }
    });
    return kit.glob(opts.patterns, {
      cwd: opts.src_dir
    }).then(function(paths) {
      return Q.all(paths.map(function(path) {
        var dest_path, src_path;
        src_path = kit.path.join(opts.src_dir, path);
        dest_path = kit.path.join(opts.dest_dir, path);
        return kit.readFile(src_path, 'utf8').then(function(str) {
          return opts.compile(str, opts.data, src_path);
        }).then(function(code) {
          return kit.outputFile(dest_path, code);
        })["catch"](function(err) {
          if (err.code !== 'EISDIR') {
            throw err;
          }
        });
      }));
    });
  },

  /**
  	 * See the https://github.com/isaacs/node-glob
  	 * @param {String | Array} patterns Minimatch pattern.
  	 * @param {Object} opts The glob options.
  	 * @return {Promise} Contains the path list.
   */
  glob: function(patterns, opts) {
    var all_paths, stat_cache;
    if (_.isString(patterns)) {
      patterns = [patterns];
    }
    all_paths = [];
    stat_cache = {};
    return Q.all(patterns.map(function(p) {
      return kit._glob(p, opts).then(function(paths) {
        _.extend(stat_cache, paths.glob.statCache);
        return all_paths = _.union(all_paths, paths);
      });
    })).then(function() {
      all_paths.stat_cache = stat_cache;
      return all_paths;
    });
  },
  _glob: function(pattern, opts) {
    var defer, g;
    defer = Q.defer();
    g = glob(pattern, opts, function(err, paths) {
      paths.glob = g;
      if (err) {
        return defer.reject;
      } else {
        return defer.resolve(paths);
      }
    });
    return defer.promise;
  },

  /**
  	 * See my [jhash][jhash] project.
  	 * [jhash]: https://github.com/ysmood/jhash
   */
  jhash: require('jhash'),

  /**
  	 * It will find the right `key/value` pair in your defined `kit.lang_set`.
  	 * If it cannot file the one, it will output the key directly.
  	 * @param  {String} cmd  The original English text.
  	 * @param  {String} lang The target language name.
  	 * @param  {String} lang_set Specific a language collection.
  	 * @return {String}
  	 * @example
  	 * Supports we have two json file in `langs_dir_path` folder.
  	 * - cn.js, content: `module.exports = { China: '中国' }`
  	 * - jp.coffee, content: `module.exports = 'Good weather.': '日和。'`
  	 *
  	 * ```coffeescript
  	 * kit.lang_load 'langs_dir_path'
  	 *
  	 * kit.lang_current = 'cn'
  	 * 'China'.l # '中国'
  	 * 'Good weather.'.l('jp') # '日和。'
  	 *
  	 * kit.lang_current = 'en'
  	 * 'China'.l # 'China'
  	 * 'Good weather.'.l('jp') # 'Good weather.'
  	 * ```
   */
  lang: function(cmd, name, lang_set) {
    var en, i, _ref;
    if (name == null) {
      name = kit.lang_current;
    }
    if (lang_set == null) {
      lang_set = kit.lang_set;
    }
    i = cmd.lastIndexOf('|');
    en = i > -1 ? cmd.slice(0, i) : cmd;
    return ((_ref = lang_set[name]) != null ? _ref[cmd] : void 0) || en;
  },

  /**
  	 * Language collections.
  	 * @type {Object}
  	 * @example
  	 * ```coffeescript
  	 * kit.lang_set = {
  	 * 	'cn': { 'China': '中国' }
  	 * }
  	 * ```
   */
  lang_set: {},

  /**
  	 * Current default language.
  	 * @type {String}
  	 * @default 'en'
   */
  lang_current: 'en',

  /**
  	 * Load language set directory and save them into
  	 * the `kit.lang_set`.
  	 * @param  {String} dir_path The directory path that contains
  	 * js or coffee files.
  	 * @example
  	 * ```coffeescript
  	 * kit.lang_load 'assets/lang'
  	 * kit.lang_current = 'cn'
  	 * kit.log 'test'.l # This may output '测试'.
  	 * ```
   */
  lang_load: function(dir_path) {
    var ext, name, p, paths, _i, _len;
    if (!_.isString(dir_path)) {
      return;
    }
    dir_path = kit.fs.realpathSync(dir_path);
    paths = kit.fs.readdirSync(dir_path);
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      p = paths[_i];
      ext = kit.path.extname(p);
      if (_.isEmpty(ext)) {
        continue;
      }
      name = kit.path.basename(p, ext);
      kit.lang_set[name] = require(kit.path.join(dir_path, name));
    }
    return Object.defineProperty(String.prototype, 'l', {
      get: function(name, lang_set) {
        return kit.lang(this, name, lang_set);
      }
    });
  },

  /**
  	 * For debugging use. Dump a colorful object.
  	 * @param  {Object} obj Your target object.
  	 * @param  {Object} opts Options. Default:
  	 * { colors: true, depth: 5 }
  	 * @return {String}
   */
  inspect: function(obj, opts) {
    var str, util;
    util = kit.require('util');
    _.defaults(opts, {
      colors: process.env.NODE_ENV === 'development',
      depth: 5
    });
    return str = util.inspect(obj, opts);
  },

  /**
  	 * A better log for debugging, it uses the `kit.inspect` to log.
  	 *
  	 * You can use terminal command like `log_reg='pattern' node app.js` to
  	 * filter the log info.
  	 *
  	 * You can use `log_trace='on' node app.js` to force each log end with a
  	 * stack trace.
  	 * @param  {Any} msg Your log message.
  	 * @param  {String} action 'log', 'error', 'warn'.
  	 * @param  {Object} opts Default is same with `kit.inspect`
   */
  log: function(msg, action, opts) {
    var log, time, time_delta;
    if (action == null) {
      action = 'log';
    }
    if (opts == null) {
      opts = {};
    }
    if (!kit.last_log_time) {
      kit.last_log_time = new Date;
      if (process.env.log_reg) {
        console.log('>> Log should match:'.yellow, process.env.log_reg);
        kit.log_reg = new RegExp(process.env.log_reg);
      }
    }
    time = new Date();
    time_delta = (+time - +kit.last_log_time).toString().magenta + 'ms';
    kit.last_log_time = time;
    time = [[kit.pad(time.getFullYear(), 4), kit.pad(time.getMonth() + 1, 2), kit.pad(time.getDate(), 2)].join('-'), [kit.pad(time.getHours(), 2), kit.pad(time.getMinutes(), 2), kit.pad(time.getSeconds(), 2)].join(':')].join(' ').grey;
    log = function() {
      var str;
      str = _.toArray(arguments).join(' ');
      if (kit.log_reg && !kit.log_reg.test(str)) {
        return;
      }
      return console[action](str.replace(/\n/g, '\n  '));
    };
    if (_.isObject(msg)) {
      log(("[" + time + "] ->\n") + kit.inspect(msg, opts), time_delta);
    } else {
      log("[" + time + "]", msg, time_delta);
    }
    if (process.env.log_trace === 'on') {
      log((new Error).stack.replace('Error:', '\nStack trace:').grey);
    }
    if (action === 'error') {
      return process.stdout.write("\u0007");
    }
  },

  /**
  	 * Monitor an application and automatically restart it when file changed.
  	 * When the monitored app exit with error, the monitor itself will also exit.
  	 * It will make sure your app crash properly.
  	 * @param  {Object} opts Defaults:
  	 * ```coffeescript
  	 * {
  	 * 	bin: 'node'
  	 * 	args: ['app.js']
  	 * 	watch_list: ['app.js']
  	 * 	mode: 'development'
  	 * }
  	 * ```
  	 * @return {Process} The child process.
   */
  monitor_app: function(opts) {
    var ps, start;
    _.defaults(opts, {
      bin: 'node',
      args: ['app.js'],
      watch_list: ['app.js'],
      mode: 'development'
    });
    ps = null;
    start = function() {
      return ps = kit.spawn(opts.bin, opts.args, kit.env_mode(opts.mode)).process;
    };
    start();
    process.on('SIGINT', function() {
      ps.kill('SIGINT');
      return process.exit();
    });
    kit.watch_files(opts.watch_list, function(path, curr, prev) {
      if (curr.mtime !== prev.mtime) {
        kit.log("Reload app, modified: ".yellow + path + '\n' + _.times(64, function() {
          return '*';
        }).join('').yellow);
        ps.kill('SIGINT');
        return start();
      }
    });
    kit.log("Monitor: ".yellow + opts.watch_list);
    return ps;
  },

  /**
  	 * Open a thing that your system can recognize.
  	 * Now only support Windows and OSX.
  	 * @param  {String} cmd  The thing you want to open.
  	 * @param  {Object} opts The options of the node native `child_process.exec`.
  	 * @return {Promise} When the child process exits.
  	 * @example
  	 * ```coffeescript
  	 * # Open a webpage with the default browser.
  	 * kit.open 'http://ysmood.org'
  	 * ```
   */
  open: function(cmd, opts) {
    var cmds, defer, exec;
    if (opts == null) {
      opts = {};
    }
    exec = kit.require('child_process').exec;
    defer = Q.defer();
    switch (process.platform) {
      case 'darwin':
        cmds = ['open'];
        break;
      case 'win32':
        cmds = ['start'];
        break;
      default:
        cmds = [];
    }
    cmds.push(cmd);
    exec(cmds.join(' '), opts, function(err, stdout, stderr) {
      if (err) {
        return defer.reject(err);
      } else {
        return defer.resolve({
          stdout: stdout,
          stderr: stderr
        });
      }
    });
    return defer.promise;
  },

  /**
  	 * String padding helper.
  	 * @param  {Sting | Number} str
  	 * @param  {Number} width
  	 * @param  {String} char Padding char. Default is '0'.
  	 * @return {String}
  	 * @example
  	 * ```coffeescript
  	 * kit.pad '1', 3 # '001'
  	 * ```
   */
  pad: function(str, width, char) {
    if (char == null) {
      char = '0';
    }
    str = str + '';
    if (str.length >= width) {
      return str;
    } else {
      return new Array(width - str.length + 1).join(char) + str;
    }
  },

  /**
  	 * A comments parser for coffee-script. Used to generate documentation automatically.
  	 * It will traverse through all the comments.
  	 * @param  {String} module_name The name of the module it belongs to.
  	 * @param  {String} code Coffee source code.
  	 * @param  {String} path The path of the source code.
  	 * @param  {Object} opts Parser options:
  	 * ```coffeescript
  	 * {
  	 * 	comment_reg: RegExp
  	 * 	split_reg: RegExp
  	 * 	tag_name_reg: RegExp
  	 * 	type_reg: RegExp
  	 * 	name_reg: RegExp
  	 * 	name_tags: ['param', 'property']
  	 * 	description_reg: RegExp
  	 * }
  	 * ```
  	 * @return {Array} The parsed comments. Each item is something like:
  	 * ```coffeescript
  	 * {
  	 * 	module: 'nobone'
  	 * 	name: 'parse_comment'
  	 * 	description: 'A comments parser for coffee-script.'
  	 * 	tags: [
  	 * 		{
  	 * 			tag_name: 'param'
  	 * 			type: 'string'
  	 * 			name: 'code'
  	 * 			description: 'The name of the module it belongs to.'
  	 * 			path: 'http://the_path_of_source_code'
  	 * 			index: 256 # The target char index in the file.
  	 * 			line: 32 # The line number of the target in the file.
  	 * 		}
  	 * 	]
  	 * }
  	 * ```
   */
  parse_comment: function(module_name, code, path, opts) {
    var comments, info, m, parse_info;
    if (path == null) {
      path = '';
    }
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      comment_reg: /###\*([\s\S]+?)###\s+([\w\.]+)/g,
      split_reg: /^\s+\* @/m,
      tag_name_reg: /^([\w\.]+)\s*/,
      type_reg: /^\{(.+?)\}\s*/,
      name_reg: /^(\w+)\s*/,
      name_tags: ['param', 'property'],
      description_reg: /^([\s\S]*)/
    });
    parse_info = function(block) {
      var arr;
      block = block.replace(/\\\//g, '/');
      arr = block.split(opts.split_reg).map(function(el) {
        return el.replace(/^[ \t]+\*[ \t]?/mg, '').trim();
      });
      return {
        description: arr[0] || '',
        tags: arr.slice(1).map(function(el) {
          var parse_tag, tag, type;
          parse_tag = function(reg) {
            var m;
            m = el.match(reg);
            if (m && m[1]) {
              el = el.slice(m[0].length);
              return m[1];
            } else {
              return null;
            }
          };
          tag = {};
          tag.tag_name = parse_tag(opts.tag_name_reg);
          type = parse_tag(opts.type_reg);
          if (type) {
            tag.type = type;
            if (opts.name_tags.indexOf(tag.tag_name) > -1) {
              tag.name = parse_tag(opts.name_reg);
            }
            tag.description = parse_tag(opts.description_reg) || '';
          } else {
            tag.description = parse_tag(opts.description_reg) || '';
          }
          return tag;
        })
      };
    };
    comments = [];
    m = null;
    while ((m = opts.comment_reg.exec(code)) !== null) {
      info = parse_info(m[1]);
      comments.push({
        module: module_name,
        name: m[2],
        description: info.description,
        tags: info.tags,
        path: path,
        index: opts.comment_reg.lastIndex,
        line: _.reduce(code.slice(0, opts.comment_reg.lastIndex), function(count, char) {
          if (char === '\n') {
            count++;
          }
          return count;
        }, 1)
      });
    }
    return comments;
  },

  /**
  	 * Node native module
   */
  path: require('path'),

  /**
  	 * Block terminal and wait for user inputs. Useful when you need
  	 * in-terminal user interaction.
  	 * @param  {Object} opts See the https://github.com/flatiron/prompt
  	 * @return {Promise} Contains the results of prompt.
   */
  prompt_get: function(opts) {
    var defer, prompt;
    prompt = kit.require('prompt', function(prompt) {
      prompt.message = '>> ';
      return prompt.delimiter = '';
    });
    defer = Q.defer();
    prompt.get(opts, function(err, res) {
      if (err) {
        return defer.reject(err);
      } else {
        return defer.resolve(res);
      }
    });
    return defer.promise;
  },

  /**
  	 * The promise Q lib.
  	 * @type {Object}
   */
  Q: Q,

  /**
  	 * Much much faster than the native require of node, but
  	 * you should follow some rules to use it safely.
  	 * @param  {String}   module_name Moudle path is not allowed!
  	 * @param  {Function} done Run only the first time after the module loaded.
  	 * @return {Module} The module that you require.
   */
  require: function(module_name, done) {
    if (!kit.require_cache[module_name]) {
      if (module_name[0] === '.') {
        throw new Error('Only module name is allowed: ' + module_name);
      }
      kit.require_cache[module_name] = require(module_name);
      if (typeof done === "function") {
        done(kit.require_cache[module_name]);
      }
    }
    return kit.require_cache[module_name];
  },

  /**
  	 * A powerful extended combination of `http.request` and `https.request`.
  	 * @param  {Object} opts The same as the [http.request][http.request], but with
  	 * some extra options:
  	 * ```coffeescript
  	 * {
  	 * 	url: 'It is not optional, String or Url Object.'
  	 * 	body: true # Other than return `res` with `res.body`, return `body` directly.
  	 * 	redirect: 0 # Max times of auto redirect. If 0, no auto redirect.
  	 *
  	 * 	# Set null to use buffer, optional.
  	 * 	# It supports GBK, Shift_JIS etc.
  	 * 	# For more info, see https://github.com/ashtuchkin/iconv-lite
  	 * 	res_encoding: 'auto'
  	 *
  	 * 	# It's string, object or buffer, optional. When it's an object,
  	 * 	# The request will be 'application/x-www-form-urlencoded'.
  	 * 	req_data: null
  	 *
  	 * 	auto_end_req: true # auto end the request.
  	 * 	req_pipe: Readable Stream.
  	 * 	res_pipe: Writable Stream.
  	 * }
  	 * ```
  	 * And if set opts as string, it will be treated as the url.
  	 * [http.request]: http://nodejs.org/api/http.html#http_http_request_options_callback
  	 * @return {Promise} Contains the http response object,
  	 * it has an extra `body` property.
  	 * You can also get the request object by using `Promise.req`, for example:
  	 * ```coffeescript
  	 * p = kit.request 'http://test.com'
  	 * p.req.on 'response', (res) ->
  	 * 	kit.log res.headers['content-length']
  	 * p.done (body) ->
  	 * 	kit.log body # html or buffer
  	 *
  	 * kit.request {
  	 * 	url: 'https://test.com'
  	 * 	body: false
  	 * }
  	 * .done (res) ->
  	 * 	kit.log res.body
  	 * 	kit.log res.headers
  	 * ```
   */
  request: function(opts) {
    var defer, req, req_buf, request, url, _base, _base1, _base2;
    if (_.isString(opts)) {
      opts = {
        url: opts
      };
    }
    if (_.isObject(opts.url)) {
      if ((_base = opts.url).protocol == null) {
        _base.protocol = 'http:';
      }
      opts.url = kit.url.format(opts.url);
    } else {
      if (opts.url.indexOf('http') !== 0) {
        opts.url = 'http://' + opts.url;
      }
    }
    url = kit.url.parse(opts.url);
    if (url.protocol == null) {
      url.protocol = 'http:';
    }
    request = null;
    switch (url.protocol) {
      case 'http:':
        request = kit.require('http').request;
        break;
      case 'https:':
        request = kit.require('https').request;
        break;
      default:
        throw new Error('Protocol not supported: ' + url.protocol);
    }
    _.defaults(opts, url);
    _.defaults(opts, {
      body: true,
      res_encoding: 'auto',
      req_data: null,
      auto_end_req: true,
      auto_unzip: true
    });
    if (opts.headers == null) {
      opts.headers = {};
    }
    if (Buffer.isBuffer(opts.req_data)) {
      req_buf = opts.req_data;
    } else if (_.isString(opts.req_data)) {
      req_buf = new Buffer(opts.req_data);
    } else if (_.isObject(opts.req_data)) {
      if ((_base1 = opts.headers)['content-type'] == null) {
        _base1['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8';
      }
      req_buf = new Buffer(_.map(opts.req_data, function(v, k) {
        return [encodeURIComponent(k), encodeURIComponent(v)].join('=');
      }).join('&'));
    } else {
      req_buf = new Buffer(0);
    }
    if (req_buf.length > 0) {
      if ((_base2 = opts.headers)['content-length'] == null) {
        _base2['content-length'] = req_buf.length;
      }
    }
    defer = Q.defer();
    req = request(opts, function(res) {
      var buf, res_pipe_error, unzip;
      if (opts.redirect > 0 && res.headers.location) {
        opts.redirect--;
        kit.request(_.extend(opts, kit.url.parse(res.headers.location)))["catch"](function(err) {
          return defer.reject(err);
        }).done(function(val) {
          return defer.resolve(val);
        });
        return;
      }
      if (opts.res_pipe) {
        res_pipe_error = function(err) {
          defer.reject(err);
          return opts.res_pipe.end();
        };
        if (opts.auto_unzip) {
          switch (res.headers['content-encoding']) {
            case 'gzip':
              unzip = kit.require('zlib').createGunzip();
              break;
            case 'deflate':
              unzip = kit.require('zlib').createInflat();
              break;
            default:
              unzip = null;
          }
          if (unzip) {
            unzip.on('error', res_pipe_error);
            res.pipe(unzip).pipe(opts.res_pipe);
          } else {
            res.pipe(opts.res_pipe);
          }
        } else {
          res.pipe(opts.res_pipe);
        }
        opts.res_pipe.on('error', res_pipe_error);
        res.on('error', res_pipe_error);
        return res.on('end', function() {
          return defer.resolve(res);
        });
      } else {
        buf = new Buffer(0);
        res.on('data', function(chunk) {
          return buf = Buffer.concat([buf, chunk]);
        });
        return res.on('end', function() {
          var c_type, decode, encoding, m, resolve;
          resolve = function(body) {
            if (opts.body) {
              return defer.resolve(body);
            } else {
              res.body = body;
              return defer.resolve(res);
            }
          };
          if (opts.res_encoding) {
            encoding = 'utf8';
            if (opts.res_encoding === 'auto') {
              c_type = res.headers['content-type'];
              if (_.isString(c_type)) {
                m = c_type.match(/charset=(.+);?/i);
                if (m && m[1]) {
                  encoding = m[1];
                }
                if (!/^(text)|(application)\//.test(c_type)) {
                  encoding = null;
                }
              }
            }
            decode = function(buf) {
              var err;
              if (!encoding) {
                return buf;
              }
              try {
                if (encoding === 'utf8') {
                  return buf.toString();
                } else {
                  return kit.require('iconv-lite').decode(buf, encoding);
                }
              } catch (_error) {
                err = _error;
                return defer.reject(err);
              }
            };
            if (opts.auto_unzip) {
              switch (res.headers['content-encoding']) {
                case 'gzip':
                  unzip = kit.require('zlib').gunzip;
                  break;
                case 'deflate':
                  unzip = kit.require('zlib').inflate;
                  break;
                default:
                  unzip = null;
              }
              if (unzip) {
                return unzip(buf, function(err, buf) {
                  return resolve(decode(buf));
                });
              } else {
                return resolve(decode(buf));
              }
            } else {
              return resolve(decode(buf));
            }
          } else {
            return resolve(buf);
          }
        });
      }
    });
    req.on('error', function(err) {
      var _ref;
      if ((_ref = opts.res_pipe) != null) {
        _ref.end();
      }
      return defer.reject(err);
    });
    if (opts.req_pipe) {
      opts.req_pipe.pipe(req);
    } else {
      if (opts.auto_end_req) {
        if (req_buf.length > 0) {
          req.end(req_buf);
        } else {
          req.end();
        }
      }
    }
    defer.promise.req = req;
    return defer.promise;
  },

  /**
  	 * A safer version of `child_process.spawn` to run a process on Windows or Linux.
  	 * It will automatically add `node_modules/.bin` to the `PATH` environment variable.
  	 * @param  {String} cmd Path of an executable program.
  	 * @param  {Array} args CLI arguments.
  	 * @param  {Object} opts Process options. Same with the Node.js official doc.
  	 * Default will inherit the parent's stdio.
  	 * @return {Promise} The `promise.process` is the child process object.
  	 * When the child process ends, it will resolve.
   */
  spawn: function(cmd, args, opts) {
    var PATH, cmd_ext, defer, err, ps, spawn, which;
    if (args == null) {
      args = [];
    }
    if (opts == null) {
      opts = {};
    }
    PATH = process.env.PATH || process.env.Path;
    [kit.path.normalize(__dirname + '/../node_modules/.bin'), kit.path.normalize(process.cwd() + '/node_modules/.bin')].forEach(function(path) {
      if (PATH.indexOf(path) < 0 && kit.fs.existsSync(path)) {
        return PATH = [path, PATH].join(kit.path.delimiter);
      }
    });
    process.env.PATH = PATH;
    process.env.Path = PATH;
    _.defaults(opts, {
      stdio: 'inherit'
    });
    if (process.platform === 'win32') {
      cmd_ext = cmd + '.cmd';
      if (fs.existsSync(cmd_ext)) {
        cmd = cmd_ext;
      } else {
        which = kit.require('which');
        cmd = which.sync(cmd);
      }
      cmd = kit.path.normalize(cmd);
    }
    defer = Q.defer();
    spawn = kit.require('child_process').spawn;
    try {
      ps = spawn(cmd, args, opts);
    } catch (_error) {
      err = _error;
      defer.reject(err);
    }
    ps.on('error', function(err) {
      return defer.reject(err);
    });
    ps.on('exit', function(worker, code, signal) {
      return defer.resolve({
        worker: worker,
        code: code,
        signal: signal
      });
    });
    defer.promise.process = ps;
    return defer.promise;
  },

  /**
  	 * Node native module
   */
  url: require('url'),

  /**
  	 * Watch a file. If the file changes, the handler will be invoked.
  	 * You can change the polling interval by using `process.env.polling_watch`.
  	 * Use `process.env.watch_persistent` to make the watcher persistent.
  	 * For samba server, we have to choose `watchFile` than `watch`.
  	 * variable.
  	 * @param  {String}   path    The file path
  	 * @param  {Function} handler Event listener.
  	 * The handler has these params:
  	 * - file path
  	 * - current `fs.Stats`
  	 * - previous `fs.Stats`
  	 * - if its a deletion
  	 * @param {Boolean} auto_unwatch Auto unwatch the file while file deletion.
  	 * Default is true.
  	 * @return {Function} The wrapped watch listeners.
  	 * @example
  	 * ```coffeescript
  	 * process.env.watch_persistent = 'on'
  	 * kit.watch_file 'a.js', (path, curr, prev, is_deletion) ->
  	 * 	if curr.mtime != prev.mtime
  	 * 		kit.log path
  	 * ```
   */
  watch_file: function(path, handler, auto_unwatch) {
    var listener;
    if (auto_unwatch == null) {
      auto_unwatch = true;
    }
    listener = function(curr, prev) {
      var is_deletion;
      is_deletion = curr.mtime.getTime() === 0;
      handler(path, curr, prev, is_deletion);
      if (is_deletion) {
        return kit.fs.unwatchFile(path, listener);
      }
    };
    fs.watchFile(path, {
      persistent: process.env.watch_persistent === 'on',
      interval: +process.env.polling_watch || 300
    }, listener);
    return listener;
  },

  /**
  	 * Watch files, when file changes, the handler will be invoked.
  	 * It takes the advantage of `kit.watch_file`.
  	 * @param  {Array} patterns String array with minimatch syntax.
  	 * Such as `['*\/**.css', 'lib\/**\/*.js']`.
  	 * @param  {Function} handler
  	 * @return {Promise} It contains the wrapped watch listeners.
  	 * @example
  	 * ```coffeescript
  	 * kit.watch_files '*.js', (path, curr, prev, is_deletion) ->
  	 * 	kit.log path
  	 * ```
   */
  watch_files: function(patterns, handler) {
    return kit.glob(patterns).then(function(paths) {
      return paths.map(function(path) {
        return kit.watch_file(path, handler);
      });
    });
  },

  /**
  	 * Watch directory and all the files in it.
  	 * It supports three types of change: create, modify, move, delete.
  	 * @param  {Object} opts Defaults:
  	 * ```coffeescript
  	 * {
  	 * 	dir: '.'
  	 * 	pattern: '**' # minimatch, string or array
  	 *
  	 * 	# Whether to watch POSIX hidden file.
  	 * 	dot: false
  	 *
  	 * 	# If the "path" ends with '/' it's a directory, else a file.
  	 * 	handler: (type, path, old_path) ->
  	 * }
  	 * ```
  	 * @return {Promise}
  	 * @example
  	 * ```coffeescript
  	 * # Only current folder, and only watch js and css file.
  	 * kit.watch_dir {
  	 * 	dir: 'lib'
  	 * 	pattern: '*.+(js|css)'
  	 * 	handler: (type, path) ->
  	 * 		kit.log type
  	 * 		kit.log path
  	 * 	watched_list: {} # If you use watch_dir recursively, you need a global watched_list
  	 * }
  	 * ```
   */
  watch_dir: function(opts) {
    var file_watcher, is_same_file, main_watch, recursive_watch;
    _.defaults(opts, {
      dir: '.',
      pattern: '**',
      dot: false,
      handler: function(type, path, old_path) {},
      watched_list: {},
      deleted_list: {}
    });
    if (_.isString(opts.pattern)) {
      opts.pattern = [opts.pattern];
    }
    is_same_file = function(stats_a, stats_b) {
      return stats_a.mtime.getTime() === stats_b.mtime.getTime() && stats_a.ctime.getTime() === stats_b.ctime.getTime() && stats_a.size === stats_b.size;
    };
    recursive_watch = function(path) {
      if (path.slice(-1) === '/') {
        return kit.watch_dir(_.defaults({
          dir: path
        }, opts));
      } else {
        return opts.watched_list[path] = kit.watch_file(path, file_watcher);
      }
    };
    file_watcher = function(path, curr, prev, is_delete) {
      if (is_delete) {
        return opts.deleted_list[path] = prev;
      } else {
        return opts.handler('modify', path);
      }
    };
    main_watch = function(path, curr, prev, is_delete) {
      if (is_delete) {
        opts.deleted_list[path] = prev;
        return;
      }
      return kit.glob(opts.pattern.map(function(el) {
        return kit.path.join(path, el);
      }), {
        mark: true,
        dot: opts.dot
      }).then(function(paths) {
        var p, _i, _len;
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          p = paths[_i];
          if (opts.watched_list[p] !== void 0) {
            continue;
          }
          if (!_.any(opts.deleted_list, function(stat, dpath) {
            if (stat === 'parent_moved') {
              delete opts.deleted_list[dpath];
              return true;
            }
            if (is_same_file(stat, paths.stat_cache[p])) {
              for (k in opts.deleted_list) {
                if (k.indexOf(dpath) === 0) {
                  opts.deleted_list[k] = 'parent_moved';
                  delete opts.watched_list[k];
                }
              }
              delete opts.deleted_list[dpath];
              recursive_watch(p);
              opts.handler('move', p, dpath);
              return true;
            } else {
              return false;
            }
          })) {
            recursive_watch(p);
            opts.handler('create', p);
          }
        }
        return _.each(opts.watched_list, function(v, wpath) {
          if (paths.indexOf(wpath) === -1 && wpath.indexOf(path) === 0) {
            delete opts.deleted_list[wpath];
            delete opts.watched_list[wpath];
            return opts.handler('delete', wpath);
          }
        });
      })["catch"](function(err) {
        return kit.err(err);
      });
    };
    return kit.glob(opts.pattern.map(function(el) {
      return kit.path.join(opts.dir, el);
    }), {
      mark: true,
      dot: opts.dot
    }).then(function(paths) {
      var path, w, _i, _len, _ref;
      _ref = paths.reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        if (path.slice(-1) === '/') {
          w = kit.watch_file(path, main_watch);
        } else {
          w = kit.watch_file(path, file_watcher);
        }
        opts.watched_list[path] = w;
      }
      return opts.watched_list;
    });
  }
});

kit.path.delimiter = process.platform === 'win32' ? ';' : ':';

module.exports = kit;
